{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2020-11-06T19:33:59.005432+00:00",
  "repo": "ietf-rats-wg/eat",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "ready to close",
      "description": "",
      "color": "bfdadc"
    },
    {
      "name": "new claim",
      "description": "",
      "color": "006b75"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "MDU6SXNzdWUzMzYzMzExNDY=",
      "title": "Manufacturer performing validation -- \"should\" or \"must\"",
      "url": "https://github.com/ietf-rats-wg/eat/issues/2",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready to close"
      ],
      "body": "Some comments so far in my reading (which is not yet complete):\r\n\r\n The Manufacturer.  The company that made the entity.  This may be a\r\n      chip vendor, a circuit board module vendor or a vendor of finished\r\n      consumer products.\r\n\r\nGiven that it may be three (or more) entities, and they each have different\r\nagendas, I think that it might be worth being specific about each level.\r\n\r\n  In this case the manufacturer should\r\n  perform the verification, because any release of the key material\r\n  would enable a participant other than the entity to create valid\r\n  signed EATs.\r\n\r\ns/manufacturer should/manufacturer MUST/",
      "createdAt": "2018-06-27T18:00:09Z",
      "updatedAt": "2019-10-04T16:10:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "We determined that definition of the trusted endpoint would be out of scope for RATS, at least initially. Normative requirements on how to manufacture a RATS device seems to fit the definition of what is out of scope.",
          "createdAt": "2019-07-22T18:05:57Z",
          "updatedAt": "2019-07-22T18:05:57Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "We can close this because the section this pertains to will be removed and go into the architecture document. Also as Ned says, normative requirements on how to manufacture are out of scope.",
          "createdAt": "2019-10-04T16:10:22Z",
          "updatedAt": "2019-10-04T16:10:22Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWUzMzYzMzE3MzQ=",
      "title": "Add claims for public keys and similar",
      "url": "https://github.com/ietf-rats-wg/eat/issues/3",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "new claim"
      ],
      "body": "(From David Wheeler)\r\n\r\nWhat seems to be missing from the proposed structure is the ability to attach new key material into the EAT structure, with an attestation claim. The attestation claim can be that it was generated on the device, or generated inside the TEE and bound/sealed to the TEE. And perhaps even a purpose for the key material. A new attestation key, for example; or a special signing/authorization key for a particular application.\r\n \r\nMany times, IMHO, it is useful to generate a new key that is attested in some way, and then future operations use that key. In fact, OTrP/TEEP has this implication, with the AIK keys for new installed Apps, but (IMO) it is not really that clearly spelled out, although I think the intention is clear.\r\n \r\nOther attestation claims are also useful \u2013 the identity and cryptographic hash of the code of a particular TEE application; a DH public key to establish an encrypted channel; the set of root CA\u2019s this TEE will trust; \u2026",
      "createdAt": "2018-06-27T18:02:04Z",
      "updatedAt": "2019-10-07T13:49:33Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mathias-arm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems to me this effort is relevant to the issue: https://datatracker.ietf.org/doc/draft-ietf-ace-cwt-proof-of-possession/",
          "createdAt": "2019-04-25T18:09:11Z",
          "updatedAt": "2019-04-25T18:09:11Z"
        },
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "Attestation is different than proof of possession it is more like proof of protection or proof of integrity. In the TPM there is an added semantic that the key can only sign (attest to) data objects that are under the control of the TPM (TEE?). This avoids a possible confused deputy attack. If a key was not generated inside the trusted environment then it is possible the key could have been exposed to an attacker. This would make it less trustworthy as an attestation key because the key potentially could sign evidence that didn't pertain to the attester.",
          "createdAt": "2019-07-22T18:12:37Z",
          "updatedAt": "2019-07-22T18:12:37Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWUzMzYzMzI1MTc=",
      "title": "Should there be both \"restricted\" and \"secure restricted\" security levels",
      "url": "https://github.com/ietf-rats-wg/eat/issues/4",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See seclevel discussion in mail list archive: https://mailarchive.ietf.org/arch/browse/eat/",
      "createdAt": "2018-06-27T18:04:43Z",
      "updatedAt": "2019-10-17T21:51:36Z",
      "closedAt": null,
      "comments": [
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "The link to mailarchive doesn't appear to show messages related to this issue. Difficult to get context. My feedback related to levels is there isn't a clear use case or security model for the levels defined here. For example, the Bell-LaPadula security model defines security levels which are meaningful in that context. However, it isn't possible to map the levels defined in EAT because BL levels also have compartments and require a TCB boundary definition. These elements are not defined by EAT. ",
          "createdAt": "2019-10-17T21:51:36Z",
          "updatedAt": "2019-10-17T21:51:36Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU0NTA0MDE0MzU=",
      "title": "Add guidance on registration of unused/lightly-used claims",
      "url": "https://github.com/ietf-rats-wg/eat/issues/9",
      "state": "CLOSED",
      "author": "gmandyam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Section 5 contains guidance on the registration of EAT claims using the CWT registry.  There should be suggested guidance to the expert reviewers to avoid registration of claims intended to be used in EAT that will not achieve widespread adoption.\r\n\r\nSee https://mailarchive.ietf.org/arch/msg/rats/jBCYPK2hly554HGYTXZXa2t_AGw. ",
      "createdAt": "2019-05-30T16:45:01Z",
      "updatedAt": "2019-07-24T20:48:19Z",
      "closedAt": "2019-07-24T20:48:18Z",
      "comments": [
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "There needs to be guidance on what \"lightly\", \"wide-spread\" and \"will be\" are intended to portray. ",
          "createdAt": "2019-07-22T18:14:16Z",
          "updatedAt": "2019-07-22T18:14:16Z"
        },
        {
          "author": "gmandyam",
          "authorAssociation": "COLLABORATOR",
          "body": "As per consensus at IETF 105, it was decided that there does not need to be additional guidance on the use of the CWT/JWT registries.  Therefore this issue is closed.",
          "createdAt": "2019-07-24T20:48:18Z",
          "updatedAt": "2019-07-24T20:48:18Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWU0NTA0MDQxNjM=",
      "title": "Add guidance on registration of claims corresponding to YANG objects",
      "url": "https://github.com/ietf-rats-wg/eat/issues/10",
      "state": "OPEN",
      "author": "gmandyam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://mailarchive.ietf.org/arch/msg/rats/jBCYPK2hly554HGYTXZXa2t_AGw.\r\n\r\nFuture claims could be added that correspond directly to YANG objects (https://tools.ietf.org/html/rfc6020).  There should be guidance in the document as to how such objects can be reflected in the CWT claims registry.\r\n\r\nFor CBOR claims, this could be as simple as providing a reference to https://datatracker.ietf.org/doc/draft-ietf-core-yang-cbor/.  It should be confirmed whether https://tools.ietf.org/html/rfc7951 is sufficient to address future JWT claims.",
      "createdAt": "2019-05-30T16:51:28Z",
      "updatedAt": "2019-10-22T18:01:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "Possibly it doesn't make sense to provide guidance unless it is thought to be needed by draft-birkholz-rats-basic-yang-module-01  and/or draft-fedorkow-rats-network-device-attestation-00 or if there is a use case that provides context for understanding how EAT tokens are used in the context of YANG encodings. Possibly, the information models in both EAT and YANG define claims that are semantically the same/similar. But the WG seems to be in favor of allowing this or at least relying on readers of the drafts to spot semantic differences. Even so, if no use case requires use of EAT (CBOR/JSON) and YANG encodings then possibly there is no compelling need to define this now.",
          "createdAt": "2019-10-17T22:07:28Z",
          "updatedAt": "2019-10-17T22:07:28Z"
        },
        {
          "author": "gmandyam",
          "authorAssociation": "COLLABORATOR",
          "body": "@nedmsmith \r\n\r\nI assume that there will be YANG claims that correspond to TPM information fields (as there already are in draft-birkholz-rats-basic-yang-module).  Having the guidance on how to add YANG claims to an EAT token (without actually specifying those claims) could allow developers to basically pick and choose which TPM information fields they would like if they wanted to enrich an EAT token, as opposed to sending an entire TPM attestation along with the EAT. ",
          "createdAt": "2019-10-17T22:58:50Z",
          "updatedAt": "2019-10-17T22:58:50Z"
        },
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "\ufeff\r\n\ufeffThe challenge is who signs the EAT token if legacy TPM doesn\u2019t know how to sign an EAT. Does it still make sense to say the same thing in an EAT if it is also said in the TPM Evidence?\r\n\r\nSent from my iPhone\r\n\r\nOn Oct 17, 2019, at 6:58 PM, gmandyam <notifications@github.com> wrote:\r\n\r\n\ufeff\r\n\r\n@nedmsmith<https://github.com/nedmsmith>\r\n\r\nI assume that there will be YANG claims that correspond to TPM information fields (as there already are in draft-birkholz-rats-basic-yang-module). Having the guidance on how to add YANG claims to an EAT token (without actually specifying those claims) could allow developers to basically pick and choose which TPM information fields they would like if they wanted to enrich an EAT token, as opposed to sending an entire TPM attestation along with the EAT.\r\n\r\n\u2014\r\nYou are receiving this because you were mentioned.\r\nReply to this email directly, view it on GitHub<https://github.com/ietf-rats-wg/eat/issues/10?email_source=notifications&email_token=ABPMCSFWLJR7EUR3EW7WQB3QPDU2XA5CNFSM4HRGZT22YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEBRZNWQ#issuecomment-543397594>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/ABPMCSFUZDO65ZPY66EYB7DQPDU2XANCNFSM4HRGZT2Q>.\r\n",
          "createdAt": "2019-10-18T05:17:50Z",
          "updatedAt": "2019-10-18T05:17:50Z"
        },
        {
          "author": "gmandyam",
          "authorAssociation": "COLLABORATOR",
          "body": ">\ufeffThe challenge is who signs the EAT token if legacy TPM doesn\u2019t know how to sign an EAT. Does it still make sense to say the same thing in an EAT if it is also said in the TPM Evidence?\r\n\r\nIf one was to attempt such an operation, then I think it would look a lot like the  signing operation described in the webauthn specification - see https://www.w3.org/TR/webauthn/#tpm-attestation.  In that case, a digest is created of the data to be signed and the digest is presented to the TPM in the TPMS_ATTEST.extraData field.  So any RP that would try to verify the EAT token would have to know what digest to expect.    If there is any information contained in the EAT token that is dynamic in nature (e.g. location in a mobile device), then I don't know how that would work.\r\n\r\nThat is why I think that if an implementation requires information equivalence between the TPM attestation and EAT, it is preferable to add the desired TPM information fields to the EAT (e.g. via a YANG claim) rather than the other way.",
          "createdAt": "2019-10-22T17:39:24Z",
          "updatedAt": "2019-10-22T17:39:24Z"
        },
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "The architectural question relates to what environment is the \u201cAttesting env\u201d and whether or not that environment is able to support an IETF RATS format (CBOR, JSON, YANG). The TPM versions support binary and in TPM2 an optional X.509 (BER) format. If the expectation of RATS is that an EAT token is needed that encapsulates the TPM attested evidence, then one should ask whether the thing creating the EAT is an \u201cAttesting\u201d environment. If it is, but isn\u2019t a TPM then the use cases (or some other specification) should inform as to whether that makes sense. Having a spec that says \u201csomething that might not be an attesting env should create an EAT except for the fact that the spec mandates it\u201d doesn\u2019t seem right.\r\n\r\nIf the idea is to use the TPMS_ATTEST.extraData field to cause the TPM (aka attesting env) to sign the EAT. However the TPM may refuse to sign with an attestation key because these keys refuse to sign data that is opaque (to the attesting env). Even so, it would be\r\n\r\nThe correct use of TPMS_ATTEST.extraData would be as a nonce to show freshness of the attestation event. This could be an EAT.nonce value. I\u2019m having difficulty understanding the use case where the EAT contains an encapsulation of the TPM signed Evidence.\r\n\r\n-Ned\r\n\r\nOn 10/22/19, 10:39 AM, \"gmandyam\" <notifications@github.com<mailto:notifications@github.com>> wrote:\r\n\r\n\r\nThe challenge is who signs the EAT token if legacy TPM doesn\u2019t know how to sign an EAT. Does it still make sense to say the same thing in an EAT if it is also said in the TPM Evidence?\r\n\r\nIf one was to attempt such an operation, then I think it would look a lot like the signing operation described in the webauthn specification - see https://www.w3.org/TR/webauthn/#tpm-attestation. In that case, a digest is created of the data to be signed and the digest is presented to the TPM in the TPMS_ATTEST.extraData field. So any RP that would try to verify the EAT token would have to know what digest to expect. If there is any information contained in the EAT token that is dynamic in nature (e.g. location in a mobile device), then I don't know how that would work.\r\n\r\nThat is why I think that if an implementation requires information equivalence between the TPM attestation and EAT, it is preferable to add the desired TPM information fields to the EAT (e.g. via a YANG claim) rather than the other way.\r\n\r\n\u2014\r\nYou are receiving this because you were mentioned.\r\nReply to this email directly, view it on GitHub<https://github.com/ietf-rats-wg/eat/issues/10?email_source=notifications&email_token=ABPMCSEWNORPHJEZM5GEJN3QP43E3A5CNFSM4HRGZT22YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEB6ST3A#issuecomment-545073644>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/ABPMCSBPF636LGY44OBPCEDQP43E3ANCNFSM4HRGZT2Q>.\r\n",
          "createdAt": "2019-10-22T18:01:04Z",
          "updatedAt": "2019-10-22T18:01:04Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU0NjM5MzMxNDg=",
      "title": "Should minimum size of UEID be larger than 128 bits?",
      "url": "https://github.com/ietf-rats-wg/eat/issues/12",
      "state": "CLOSED",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready to close"
      ],
      "body": "Ben commented that 128 bits is not enough. Is my analysis correct?\r\n\r\n128 bits (16 bytes) is enough for one trillion humans to each have one trillion devices and the probability of collision less than a trillion (log base 10 of 2^ 128 = 38; log base 10 of a trillion is 12; 3 * 12 < 38) So 128 bits seems like enough, but take it out to 256 bits because SHA-256 is popular and good and there is some extra margin.",
      "createdAt": "2019-07-03T20:12:32Z",
      "updatedAt": "2020-11-03T18:35:33Z",
      "closedAt": "2020-11-03T18:35:33Z",
      "comments": [
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "Simply anticipating a namespace large enough to create a universally unique value doesn't ensure there will not be collisions. Often there is a namespace authority that applies a formula for testing uniqueness / collisions. This implies the namespace authority plays a role. For example, X.509 serial numbers are unique within the context of the issuing CA. The issuing CA is the namespace authority. The EUID definition implies namespace authorities exist for example the first 8 bytes of an IMEI identifies the mobile equipment vendor. Presumably the serial numbers are chosen by the vendor. \r\nIt isn't clear that all EUIDs will have bits reserved for namespace authorities and that there will be some way to register them.",
          "createdAt": "2019-07-22T18:28:00Z",
          "updatedAt": "2019-07-22T18:28:00Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "PR #35 includes a full probabilistic analysis rather than the poor one in my comment above.\r\n\r\n@nedmsmith -- the details in the EAT draft propose several types of UEIDs, some based on existing on device ID schemes guaranteed by a central database and one based purely on cryptographic quality large random numbers.",
          "createdAt": "2019-10-07T04:17:19Z",
          "updatedAt": "2019-10-07T04:18:23Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #35",
          "createdAt": "2020-02-29T16:51:04Z",
          "updatedAt": "2020-02-29T16:51:04Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU0Njc4ODYxODM=",
      "title": "Add privacy considerations for location claim",
      "url": "https://github.com/ietf-rats-wg/eat/issues/13",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-07-14T21:23:58Z",
      "updatedAt": "2019-07-14T21:23:58Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU0Njg0MzQwNzQ=",
      "title": "CDDL in section 4.4.1 for location is wrong",
      "url": "https://github.com/ietf-rats-wg/eat/issues/14",
      "state": "CLOSED",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "missing \"=\"\r\n",
      "createdAt": "2019-07-16T03:52:30Z",
      "updatedAt": "2019-07-17T03:58:30Z",
      "closedAt": "2019-07-17T03:58:29Z",
      "comments": [
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed and pushed.",
          "createdAt": "2019-07-17T03:58:29Z",
          "updatedAt": "2019-07-17T03:58:29Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU0Njg0MzQ5ODY=",
      "title": "should / must consistency",
      "url": "https://github.com/ietf-rats-wg/eat/issues/15",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-07-16T03:57:08Z",
      "updatedAt": "2019-07-16T03:57:08Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU0Njg1NjkxMTU=",
      "title": "Definition and usage of the term 'entity'",
      "url": "https://github.com/ietf-rats-wg/eat/issues/16",
      "state": "OPEN",
      "author": "carl-wallace",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In section 1.2, it seems odd that the definition of the term \"entity\" is limited to things that implement this draft. The last sentence of this section and the definition of \"The Entity\" in section 1.3 bear this out. Generally, 'entity' is used pretty loosely throughout the draft.",
      "createdAt": "2019-07-16T10:15:16Z",
      "updatedAt": "2020-02-29T17:03:42Z",
      "closedAt": null,
      "comments": [
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "The architecture and terminology draft should define 'entity' and other terms that are consistently used within related drafts. Given they are progressing at different rates, it may be appropriate for EAT draft to qualify its use of terms at least temporarily. ",
          "createdAt": "2019-07-22T19:12:23Z",
          "updatedAt": "2019-07-22T19:12:23Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "This can be closed because of the expectation that the architecture document will define entity.",
          "createdAt": "2019-10-04T16:12:39Z",
          "updatedAt": "2019-10-04T16:12:39Z"
        },
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "Agree.\r\n\r\nArchitecture defines Entity as:\r\n   Entity:  a user, organization, device or computing environment.\r\n\r\n   Principal:  an Entity that implements RATS Roles and creates provable\r\n      Claims or Attestation Results (see [ABLP] and [Lampson2007]).\r\n\r\nIf these semantics align with expected EAT semantics then it seems like the issue can be closed.\r\n\r\n-Ned\r\n\r\nOn 10/4/19, 9:12 AM, \"Laurence Lundblade\" <notifications@github.com<mailto:notifications@github.com>> wrote:\r\n\r\n\r\nThis can be closed because of the expectation that the architecture document will define entity.\r\n\r\n\u2014\r\nYou are receiving this because you commented.\r\nReply to this email directly, view it on GitHub<https://github.com/ietf-rats-wg/eat/issues/16?email_source=notifications&email_token=ABPMCSBZKEW6N5ABYPX6NODQM5TPTA5CNFSM4ID7KXSKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEAMEYSQ#issuecomment-538463306>, or mute the thread<https://github.com/notifications/unsubscribe-auth/ABPMCSCQC6PK3Q7OLEKVG63QM5TPTANCNFSM4ID7KXSA>.\r\n",
          "createdAt": "2019-10-04T17:22:41Z",
          "updatedAt": "2019-10-04T17:22:41Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "EAT and Architecture are absolutely NOT aligned on the term entity. See my recent email comments on the architecture document.\r\n\r\nMy basis for closure is that the architecture document will define some term that is the is used to refer to the subject of the attestation. Maybe we shouldn't close this until the architecture doc starts tracking issues formally.",
          "createdAt": "2019-10-04T17:27:32Z",
          "updatedAt": "2019-10-04T17:27:32Z"
        },
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "The architecture defines:\r\n\r\n  *   Entity:  a user, organization, device or computing environment.\r\n  *   Principal:  an Entity that implements RATS Roles and creates provable Claims or Attestation Results (see [ABLP] and [Lampson2007]).\r\n  *   Attesting Computing Environment:  a Computing Environment capable of monitoring and attesting a target Computing Environment.\r\n  *   Attested Computing Environment:  a target Computing Environment that is monitored and attested by an Attesting Computing Environment.\r\n\r\nThe attested computing environment is the subject of attestation which clearly is creating provable claims.\r\n\r\nThe \u2018attested\u2019 environment may be less clearly a Principal. At one point the list suggested the architecture should define a term \u201ctarget of attestation\u201d or \u201cattestation target\u201d (or something similar). The term \u201cattested computing environment\u201d seems close to this. Do we think the attested environment is semantically the same as \u201csubject of the attestation\u201d?\r\n\r\nUsing Lampson\u2019s definition of Principal, an expression of attributes (aka claims) is itself a principal.\r\n\r\nThere are lots of cases where \u2018entity\u2019 is used to refer to organizations and users (see https://csrc.nist.gov/glossary/term/entity ). Given the broad use of the term to mean: a \u201cuser, organization, device or process\u201d it might not make sense for RATs to change its scope. The RATS Arch used the term \u201ccomputing environment\u201d instead of process because not every computing environment has an operating system.\r\n\r\nAn \u201cattested computing environment\u201d is clearly intended to be a \u201ccomputing environment\u201d and hence is an Entity according to the arch draft.\r\n\r\nIf the EAT draft\u2019s use of entity is semantically equal to the architecture draft use of \u201cattested computing environment\u201d then possibly it makes sense for the EAT draft to begin using this term instead?\r\n\r\nThe architecture draft potentially could be more clear as to whether an \u201cAttested computing environment\u201d is both an entity and a principal or just an entity. It seems clear that an \u201cattesting computing environment\u201d is a Principal.\r\n\r\nNed\r\n\r\nOn 10/4/19, 10:27 AM, \"Laurence Lundblade\" <notifications@github.com<mailto:notifications@github.com>> wrote:\r\n\r\n\r\nEAT and Architecture are absolutely NOT aligned on the term entity. See my recent email comments on the architecture document.\r\n\r\nMy basis for closure is that the architecture document will define some term that is the is used to refer to the subject of the attestation. Maybe we shouldn't close this until the architecture doc starts tracking issues formally.\r\n\r\n\u2014\r\nYou are receiving this because you commented.\r\nReply to this email directly, view it on GitHub<https://github.com/ietf-rats-wg/eat/issues/16?email_source=notifications&email_token=ABPMCSG6S47KPNKHPDRK3TDQM54ILA5CNFSM4ID7KXSKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEAMLBKY#issuecomment-538489003>, or mute the thread<https://github.com/notifications/unsubscribe-auth/ABPMCSAPK5BFFBWNGO2SLZTQM54ILANCNFSM4ID7KXSA>.\r\n",
          "createdAt": "2019-10-04T17:56:42Z",
          "updatedAt": "2019-10-04T17:56:42Z"
        },
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "On Fri, Oct 4, 2019 at 1:56 PM Smith, Ned <ned.smith@intel.com> wrote:\n\n> The architecture defines:\n>\n>    - Entity:  a user, organization, device or computing environment.\n>    - Principal:  an Entity that implements RATS Roles and creates\n>    provable Claims or Attestation Results (see [ABLP] and [Lampson2007]).\n>    - Attesting Computing Environment:  a Computing Environment capable of\n>    monitoring and attesting a target Computing Environment.\n>    - Attested Computing Environment:  a target Computing Environment that\n>    is monitored and attested by an Attesting Computing Environment.\n>\n>\n>\n> The attested computing environment is the subject of attestation which\n> clearly is creating provable claims.\n>\n>\n>\n> The \u2018attested\u2019 environment may be less clearly a Principal. At one point\n> the list suggested the architecture should define a term \u201ctarget of\n> attestation\u201d or \u201cattestation target\u201d (or something similar). The term\n> \u201cattested computing environment\u201d seems close to this. Do we think the\n> attested environment is semantically the same as \u201csubject of the\n> attestation\u201d?\n>\n>\n>\n> Using Lampson\u2019s definition of Principal, an expression of attributes (aka\n> claims) is itself a principal.\n>\n>\n>\n> There are lots of cases where \u2018entity\u2019 is used to refer to organizations\n> and users (see https://csrc.nist.gov/glossary/term/entity ). Given the\n> broad use of the term to mean: a \u201cuser, organization, device or process\u201d it\n> might not make sense for RATs to change its scope. The RATS Arch used the\n> term \u201ccomputing environment\u201d instead of process because not every computing\n> environment has an operating system.\n>\n>\n>\n> An \u201cattested computing environment\u201d is clearly intended to be a \u201ccomputing\n> environment\u201d and hence is an Entity according to the arch draft.\n>\n\nAnd from a review of the EAT draft (again), I am reading this as the\nattestation based on the installed code with the attestation performed at\nboot to match what was installed.  This would verify that the code was what\nthe system administrator installed and configured.  As opposed to code\nbeing attested by the creator, which might be done with the same format,\nbut would assure the code was as he creator expected.\n\nI'm asking about this clarification in light of supply chain and the flow\ndocument:\nhttps://datatracker.ietf.org/doc/draft-fedorkow-rats-network-device-attestation/?include_text=1\n\nDoes the supply chain use case hold in these definitions or is there some\nreason why we might not care about attestations on code from the originator\nthat might include code it relies upon when chained attestations are\nconsidered?  This would expand out the definition of entity as well.\n\n\n>\n> If the EAT draft\u2019s use of entity is semantically equal to the architecture\n> draft use of \u201cattested computing environment\u201d then possibly it makes sense\n> for the EAT draft to begin using this term instead?\n>\n>\n>\n> The architecture draft potentially could be more clear as to whether an\n> \u201cAttested computing environment\u201d is both an entity and a principal or just\n> an entity. It seems clear that an \u201cattesting computing environment\u201d is a\n> Principal.\n>\n\nIs EAT limited to 'attested computing environments' or a broader definition\nof entity?\n\nKathleen\n\n\n>\n> Ned\n>\n>\n>\n> On 10/4/19, 10:27 AM, \"Laurence Lundblade\" <notifications@github.com>\n> wrote:\n>\n>\n>\n> EAT and Architecture are absolutely NOT aligned on the term entity. See my\n> recent email comments on the architecture document.\n>\n> My basis for closure is that the architecture document will define some\n> term that is the is used to refer to the subject of the attestation. Maybe\n> we shouldn't close this until the architecture doc starts tracking issues\n> formally.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-rats-wg/eat/issues/16?email_source=notifications&email_token=ABPMCSG6S47KPNKHPDRK3TDQM54ILA5CNFSM4ID7KXSKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEAMLBKY#issuecomment-538489003>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABPMCSAPK5BFFBWNGO2SLZTQM54ILANCNFSM4ID7KXSA>\n> .\n> _______________________________________________\n> RATS mailing list\n> RATS@ietf.org\n> https://www.ietf.org/mailman/listinfo/rats\n>\n\n\n-- \n\nBest regards,\nKathleen\n",
          "createdAt": "2019-10-04T19:17:05Z",
          "updatedAt": "2019-10-04T19:17:05Z"
        },
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "See inline [nms]\r\n\r\nOn 10/4/19, 12:17 PM, \"Kathleen Moriarty\" <kathleen.moriarty.ietf@gmail.com<mailto:kathleen.moriarty.ietf@gmail.com>> wrote:\r\n\r\n\r\n\r\nOn Fri, Oct 4, 2019 at 1:56 PM Smith, Ned <ned.smith@intel.com<mailto:ned.smith@intel.com>> wrote:\r\nThe architecture defines:\r\n\r\n\u00b7 Entity:  a user, organization, device or computing environment.\r\n\r\n\u00b7 Principal:  an Entity that implements RATS Roles and creates provable Claims or Attestation Results (see [ABLP] and [Lampson2007]).\r\n\r\n\u00b7 Attesting Computing Environment:  a Computing Environment capable of monitoring and attesting a target Computing Environment.\r\n\r\n\u00b7 Attested Computing Environment:  a target Computing Environment that is monitored and attested by an Attesting Computing Environment.\r\n\r\nThe attested computing environment is the subject of attestation which clearly is creating provable claims.\r\n\r\nThe \u2018attested\u2019 environment may be less clearly a Principal. At one point the list suggested the architecture should define a term \u201ctarget of attestation\u201d or \u201cattestation target\u201d (or something similar). The term \u201cattested computing environment\u201d seems close to this. Do we think the attested environment is semantically the same as \u201csubject of the attestation\u201d?\r\n\r\nUsing Lampson\u2019s definition of Principal, an expression of attributes (aka claims) is itself a principal.\r\n\r\nThere are lots of cases where \u2018entity\u2019 is used to refer to organizations and users (see https://csrc.nist.gov/glossary/term/entity ). Given the broad use of the term to mean: a \u201cuser, organization, device or process\u201d it might not make sense for RATs to change its scope. The RATS Arch used the term \u201ccomputing environment\u201d instead of process because not every computing environment has an operating system.\r\n\r\nAn \u201cattested computing environment\u201d is clearly intended to be a \u201ccomputing environment\u201d and hence is an Entity according to the arch draft.\r\n\r\nAnd from a review of the EAT draft (again), I am reading this as the attestation based on the installed code with the attestation performed at boot to match what was installed.  This would verify that the code was what the system administrator installed and configured.  As opposed to code being attested by the creator, which might be done with the same format, but would assure the code was as he creator expected.\r\n\r\nI'm asking about this clarification in light of supply chain and the flow document:\r\nhttps://datatracker.ietf.org/doc/draft-fedorkow-rats-network-device-attestation/?include_text=1\r\n\r\nDoes the supply chain use case hold in these definitions or is there some reason why we might not care about attestations on code from the originator that might include code it relies upon when chained attestations are considered?  This would expand out the definition of entity as well.\r\n[nms] The RATS architecture describes the \u201cattestations on code from the originator\u201d as \u201cEndorsements\u201d from \u201cAsserters\u201d. The architecture tries to avoid using the term \u201cattestation\u201d in this context as collection of reference values (Endorsements) isn\u2019t the same as providing proof and evidence (and the charter ruled this out of scope for now). The NIST definition of Entity includes supply chain entities (aka Asserters).\r\n\r\nIf the RATS charter were updated to allow definition of \u201cEndorsements\u201d it might make sense to propose using JWT/CWT as a binding. The Architecture draft defines endorsements [here] as a specialization of Claims. Claims in Evidence can be semantically linked to claims in Endorsements. This is intentional so that verification is less susceptible to semantic misdirection.\r\n[here]\r\n\r\n  *   Endorsements are reference Claims about the environment protecting the Attesters capabilities to create believable Evidence (e.g. the type of protection for an attestation key).  It answers the question \"why Evidence is believable\".\r\n\r\n\r\nIf the EAT draft\u2019s use of entity is semantically equal to the architecture draft use of \u201cattested computing environment\u201d then possibly it makes sense for the EAT draft to begin using this term instead?\r\n\r\nThe architecture draft potentially could be more clear as to whether an \u201cAttested computing environment\u201d is both an entity and a principal or just an entity. It seems clear that an \u201cattesting computing environment\u201d is a Principal.\r\n\r\nIs EAT limited to 'attested computing environments' or a broader definition of entity?\r\n\r\nKathleen\r\n\r\n\r\nNed\r\n\r\nOn 10/4/19, 10:27 AM, \"Laurence Lundblade\" <notifications@github.com<mailto:notifications@github.com>> wrote:\r\n\r\n\r\nEAT and Architecture are absolutely NOT aligned on the term entity. See my recent email comments on the architecture document.\r\n\r\nMy basis for closure is that the architecture document will define some term that is the is used to refer to the subject of the attestation. Maybe we shouldn't close this until the architecture doc starts tracking issues formally.\r\n\r\n\u2014\r\nYou are receiving this because you commented.\r\nReply to this email directly, view it on GitHub<https://github.com/ietf-rats-wg/eat/issues/16?email_source=notifications&email_token=ABPMCSG6S47KPNKHPDRK3TDQM54ILA5CNFSM4ID7KXSKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEAMLBKY#issuecomment-538489003>, or mute the thread<https://github.com/notifications/unsubscribe-auth/ABPMCSAPK5BFFBWNGO2SLZTQM54ILANCNFSM4ID7KXSA>.\r\n_______________________________________________\r\nRATS mailing list\r\nRATS@ietf.org<mailto:RATS@ietf.org>\r\nhttps://www.ietf.org/mailman/listinfo/rats\r\n\r\n\r\n--\r\n\r\nBest regards,\r\nKathleen\r\n",
          "createdAt": "2019-10-04T19:53:33Z",
          "updatedAt": "2019-10-04T19:53:33Z"
        },
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "On Fri, Oct 4, 2019 at 3:53 PM Smith, Ned <ned.smith@intel.com> wrote:\n\n> See inline [nms]\n>\n>\n>\n> On 10/4/19, 12:17 PM, \"Kathleen Moriarty\" <\n> kathleen.moriarty.ietf@gmail.com> wrote:\n>\n>\n>\n>\n>\n>\n>\n> On Fri, Oct 4, 2019 at 1:56 PM Smith, Ned <ned.smith@intel.com> wrote:\n>\n> The architecture defines:\n>\n> \u00b7 Entity:  a user, organization, device or computing environment.\n>\n> \u00b7 Principal:  an Entity that implements RATS Roles and creates provable\n> Claims or Attestation Results (see [ABLP] and [Lampson2007]).\n>\n> \u00b7 Attesting Computing Environment:  a Computing Environment capable of\n> monitoring and attesting a target Computing Environment.\n>\n> \u00b7 Attested Computing Environment:  a target Computing Environment that is\n> monitored and attested by an Attesting Computing Environment.\n>\n>\n>\n> The attested computing environment is the subject of attestation which\n> clearly is creating provable claims.\n>\n>\n>\n> The \u2018attested\u2019 environment may be less clearly a Principal. At one point\n> the list suggested the architecture should define a term \u201ctarget of\n> attestation\u201d or \u201cattestation target\u201d (or something similar). The term\n> \u201cattested computing environment\u201d seems close to this. Do we think the\n> attested environment is semantically the same as \u201csubject of the\n> attestation\u201d?\n>\n>\n>\n> Using Lampson\u2019s definition of Principal, an expression of attributes (aka\n> claims) is itself a principal.\n>\n>\n>\n> There are lots of cases where \u2018entity\u2019 is used to refer to organizations\n> and users (see https://csrc.nist.gov/glossary/term/entity ). Given the\n> broad use of the term to mean: a \u201cuser, organization, device or process\u201d it\n> might not make sense for RATs to change its scope. The RATS Arch used the\n> term \u201ccomputing environment\u201d instead of process because not every computing\n> environment has an operating system.\n>\n>\n>\n> An \u201cattested computing environment\u201d is clearly intended to be a \u201ccomputing\n> environment\u201d and hence is an Entity according to the arch draft.\n>\n>\n>\n> And from a review of the EAT draft (again), I am reading this as the\n> attestation based on the installed code with the attestation performed at\n> boot to match what was installed.  This would verify that the code was what\n> the system administrator installed and configured.  As opposed to code\n> being attested by the creator, which might be done with the same format,\n> but would assure the code was as he creator expected.\n>\n>\n>\n> I'm asking about this clarification in light of supply chain and the flow\n> document:\n>\n>\n> https://datatracker.ietf.org/doc/draft-fedorkow-rats-network-device-attestation/?include_text=1\n>\n>\n>\n> Does the supply chain use case hold in these definitions or is there some\n> reason why we might not care about attestations on code from the originator\n> that might include code it relies upon when chained attestations are\n> considered?  This would expand out the definition of entity as well.\n>\n> [nms] The RATS architecture describes the \u201cattestations on code from the\n> originator\u201d as \u201cEndorsements\u201d from \u201cAsserters\u201d. The architecture tries to\n> avoid using the term \u201cattestation\u201d in this context as collection of\n> reference values (Endorsements) isn\u2019t the same as providing proof and\n> evidence (and the charter ruled this out of scope for now). The NIST\n> definition of Entity includes supply chain entities (aka Asserters).\n>\n>\n>\n> If the RATS charter were updated to allow definition of \u201cEndorsements\u201d it\n> might make sense to propose using JWT/CWT as a binding.\n>\n\nCould an endorsement be a form of attestation so the charter does not need\nto be updated?  If we wind up with lots of formats, it'll be impossible to\nmanage with code being used by an entity for which they each chose their\nown format. From the submitted flow draft that covers this scenario, I'm\nnot sure the terminology was clear enough on the point to separate those\nout and intentionally exclude endorsements.\n\n\n> The Architecture draft defines endorsements [here] as a specialization of\n> Claims. Claims in Evidence can be semantically linked to claims in\n> Endorsements. This is intentional so that verification is less susceptible\n> to semantic misdirection.\n>\n> [here]\n>\n>    - Endorsements are reference Claims about the environment protecting\n>    the Attesters capabilities to create believable Evidence (e.g. the type of\n>    protection for an attestation key).  It answers the question \"why Evidence\n>    is believable\".\n>\n>\n>\nThis was helpful, thank you.\nKathleen\n\n>\n>\n> If the EAT draft\u2019s use of entity is semantically equal to the architecture\n> draft use of \u201cattested computing environment\u201d then possibly it makes sense\n> for the EAT draft to begin using this term instead?\n>\n>\n>\n> The architecture draft potentially could be more clear as to whether an\n> \u201cAttested computing environment\u201d is both an entity and a principal or just\n> an entity. It seems clear that an \u201cattesting computing environment\u201d is a\n> Principal.\n>\n>\n>\n> Is EAT limited to 'attested computing environments' or a broader\n> definition of entity?\n>\n>\n>\n> Kathleen\n>\n>\n>\n>\n>\n> Ned\n>\n>\n>\n> On 10/4/19, 10:27 AM, \"Laurence Lundblade\" <notifications@github.com>\n> wrote:\n>\n>\n>\n> EAT and Architecture are absolutely NOT aligned on the term entity. See my\n> recent email comments on the architecture document.\n>\n> My basis for closure is that the architecture document will define some\n> term that is the is used to refer to the subject of the attestation. Maybe\n> we shouldn't close this until the architecture doc starts tracking issues\n> formally.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/ietf-rats-wg/eat/issues/16?email_source=notifications&email_token=ABPMCSG6S47KPNKHPDRK3TDQM54ILA5CNFSM4ID7KXSKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEAMLBKY#issuecomment-538489003>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABPMCSAPK5BFFBWNGO2SLZTQM54ILANCNFSM4ID7KXSA>\n> .\n>\n> _______________________________________________\n> RATS mailing list\n> RATS@ietf.org\n> https://www.ietf.org/mailman/listinfo/rats\n>\n>\n>\n>\n> --\n>\n>\n>\n> Best regards,\n>\n> Kathleen\n>\n\n\n-- \n\nBest regards,\nKathleen\n",
          "createdAt": "2019-10-04T20:02:35Z",
          "updatedAt": "2019-10-04T20:02:35Z"
        },
        {
          "author": "henkbirkholz",
          "authorAssociation": "COLLABORATOR",
          "body": "TL;DR yes, endorsements are a \"form of attestation\", but they are not attestation evidence. Endorsements are part of the attestation provisioning workflows.\r\n\r\n\r\nDuring the chartering, the proponents made their case for a complete inclusion of remote attestation procedures and the resulting consensus was to do phases via chartering. There was a split into the \"attestation evidence workflows\", which is currently chartered, and the \"attestation provisioning workflows\", which is not currently chartered.\r\n\r\nIn achieving this compromise, the proponents where also adamant about including both workflows in the architecture I-D from the very beginning (as an \"exception\" so to speak) and luckily this also reached consensus - otherwise the document would not really make sense.\r\n\r\nTo answer your question: yes, endorsements are a \"form of attestation\". Nevertheless they are not attestation evidence, but part of the attestation provisioning workflows. This is also the reason why the RATS terminology is rather complex. To simply \"attest to something\" or \"conduct attestation\" is semantically mixing two quite separate and distinct workflows.\r\n\r\nThe authors of the architecture I-D are very invested in unifying as much as they can in this first phase though. Currently, the architecture I-D defines Evidence, Endorsements & Reference Values to be composed of Claims. The context gives them different scope, audience and intent, e.g. Attestation Evidence in the form of an EAT. That means we are using assertions and claims basically as synonyms, which is a bit tricky because in the IETF a Claim is a specialization of assertion and a data model concept used in web tokens. In RATS and especially in the RATS EAT I-D, Claims MAY be key value pairs in JWT or CWT that can be registered in IANA registries, but Claims MAY also be assertions that are represented in other data models (most prominently attributes in pub-key/identity or attribute certificates and YANG modules).\r\n\r\n\"Winding up with lots of formats\": We surely want to prevent that, but we have to take into account what is used today globally.\r\n\r\n\"Terminology in the submitted flow draft that covers this scenario\": While draft-fedorkow-rats-network-device-attestation makes use of concepts such as IDevID, LDevID, IAK and LAK, it does not elaborate on Endorsements and EK, which is okay, because they are.. well, currently out-of-scope. I know (obviously) that draft-birkholz-rats-tuda does use endorsement documents and corresponding endorsement keys, but that work was started before the chartering of RATS.",
          "createdAt": "2019-10-04T21:44:49Z",
          "updatedAt": "2019-10-04T21:44:49Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWU0Njg1NzAyOTg=",
      "title": "SHOULD or MUST re: cryptographic verifiability",
      "url": "https://github.com/ietf-rats-wg/eat/issues/17",
      "state": "OPEN",
      "author": "carl-wallace",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is possibly subsumed by issue 15. In section 1.2, why state \"the attestation should be cryptographically verifiable by the EAT consumer\"? Is the intent that some EAT consumers won't recognize the root of trust or that some EATs need not be cryptographically verifiable at all? If the former, maybe change from should to MUST and add qualifying words about root of trust for relying parties. ",
      "createdAt": "2019-07-16T10:17:55Z",
      "updatedAt": "2019-07-23T16:01:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "Issue #23 seems to assert that claims are optional (except where Verifier policies make them mandatory). Issue #15 may have to do with how claims are packaged and attested (e.g. signed). It is possible for signing to take place at the data layer (aka via a signed manifest structure) or at a protocol layer (aka TLS). If the requirement for attestation is that claims MUST be signed. It seems there could be flexibility regarding what layer the signature is applied (protocol or data structure). It would not (likely) make sense to sign using the same key twice simply to satisfy normative that places the signing at the data structure layer.",
          "createdAt": "2019-07-22T19:10:02Z",
          "updatedAt": "2019-07-22T19:10:02Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Section 1.2 is intended as general introductory text to help the reader orient. \r\n\r\nMy proposed solution here is to remove the \"should\" and generally soften into more descriptive language. ",
          "createdAt": "2019-07-23T16:01:13Z",
          "updatedAt": "2019-07-23T16:01:13Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "MDU6SXNzdWU0NzA1MDgwMTU=",
      "title": "Consider adding verification procedures",
      "url": "https://github.com/ietf-rats-wg/eat/issues/18",
      "state": "OPEN",
      "author": "gmandyam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready to close"
      ],
      "body": "Guidance on verification procedures not covered in document.  It is touched upon in Sec. 1.3, but not to the level described in comparable specifications (see https://www.w3.org/TR/webauthn/#defined-attestation-formats).",
      "createdAt": "2019-07-19T19:39:58Z",
      "updatedAt": "2019-10-04T16:52:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "The architecture draft should define the scope of verification semantics in terms of 'duties' and if it is appropriate for the Attester to be allowed to specify 'verification procedures' that the Verifier should follow. Verifiers are presumed to be authoritative entities regarding evaluation of evidence. It isn't clear if there is a goal to define interoperability between multiple verifier entities (something that isn't currently anticipated by the architecture IMO.)",
          "createdAt": "2019-07-22T19:02:17Z",
          "updatedAt": "2019-07-22T19:02:17Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "EAT inherits verification procedures from JWT and CWT so no need for it in the EAT document. \r\n\r\nWe could add some things over and above CWT and JWT, but I don't see anything obvious.\r\n\r\nStuff could also go in the architecture document or in individual profile documents.\r\n\r\n",
          "createdAt": "2019-07-23T15:49:28Z",
          "updatedAt": "2019-07-23T15:49:28Z"
        },
        {
          "author": "gmandyam",
          "authorAssociation": "COLLABORATOR",
          "body": "@laurencelundblade @nedmsmith \r\n\r\nI had some motivations for raising this issue:\r\n\r\na) To improve readability of the document by grouping all verification guidance into one section.  This would apply even if we think the guidance can be limited to \"Use COSE verification procedures\" and/or \"the verifier can ignore claims that it has no interest in or cannot interpret\" (as crude examples).\r\n\r\nb) Since EAT is a CWT (or JWT - still to be confirmed by group), it inherits the claim set from CWT.  There are some claims in CWT whose relationship to EAT claims is not obvious and could be subject to varying interpretations.  Some examples:\r\n    i. aud claim.  If present, does the verifier have to have a relationship with the entity identified by 'aud'?    Should the token be rejected if the verifier does not recognize 'aud'?\r\n   ii. iat and age/uptime claims.  Should the verifier treat iat independently of age/uptime, or can the verifier cast them to a common timeline?  This may affect how the verifier assesses the claims in the context of security (e.g. stale location state with respect to when the token was created).\r\n\r\nWe don't need to be prescriptive, but we can provide general guidance in the processing of claims.\r\n\r\nc) Verification of nested EATs and aggregated EATs.  If different verifiers are employed for different EAT's in a nested or aggregated structure, how do the verifiers interoperate?  Note that this may be better handled in the architecture doc, but the -01 version of the document treats the verifier as a monolith.  I believe this is also the nature the comment by @nedmsmith above.",
          "createdAt": "2019-07-23T16:37:40Z",
          "updatedAt": "2019-07-23T16:37:40Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Saying this in a different way -- EAT inherits verification from CWT (and JWT). It would only not inherit if we explicitly said so. I don't think we should do that.\r\n\r\nNote that the verification text in CWT and JWT result in a valid map payload. It doesn't go into anything about the claims details at all.\r\n\r\nIt seems we have an overload on the word \"verify\" in that some of the larger RATS architecture docs use the term for checking that the claims have acceptable values. \r\nThis is different from the verification in CWT and JWT. \r\n\r\nSo net-net, I don't think the EAT draft should discuss either forms of verification.\r\n\r\nI think the issue of claims meaning being different in the EAT context is an issue and you should file a separate GitHub issue for it.\r\n\r\n",
          "createdAt": "2019-07-23T18:07:16Z",
          "updatedAt": "2019-07-23T18:07:16Z"
        },
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "+1 on a) and b)\r\n\r\nRegarding c) the TEEP WG observed yesterday that there can be multiple TEEs in a platform/device each having the ability to attest to something. That implies there will be different keys used to attest to claims (assertions) that are specific to the respective TEE. It was also observed that there will be a mix of vendor specific and vendor independent claims that could be asserted. I expect there will be vendor specific opaque values that only a vendor-specific verifier will be able to crack. All of the above needs to be conveyed by the attestation mechanisms. Verifiers will need to be able to navigate the complexity somehow.\r\n\r\nOn 7/23/19, 12:37 PM, \"gmandyam\" <notifications@github.com<mailto:notifications@github.com>> wrote:\r\n\r\n\r\n@laurencelundblade<https://github.com/laurencelundblade> @nedmsmith<https://github.com/nedmsmith>\r\n\r\nI had some motivations for raising this issue:\r\n\r\na) To improve readability of the document by grouping all verification guidance into one section. This would apply even if we think the guidance can be limited to \"Use COSE verification procedures\" and/or \"the verifier can ignore claims that it has no interest in or cannot interpret\" (as crude examples).\r\n\r\nb) Since EAT is a CWT (or JWT - still to be confirmed by group), it inherits the claim set from CWT. There are some claims in CWT whose relationship to EAT claims is not obvious and could be subject to varying interpretations. Some examples:\r\ni. aud claim. If present, does the verifier have to have a relationship with the entity identified by 'aud'? Should the token be rejected if the verifier does not recognize 'aud'?\r\nii. iat and age/uptime claims. Should the verifier treat iat independently of age/uptime, or can the verifier cast them to a common timeline? This may affect how the verifier assesses the claims in the context of security (e.g. stale location state with respect to when the token was created).\r\n\r\nWe don't need to be prescriptive, but we can provide general guidance in the processing of claims.\r\n\r\nc) Verification of nested EATs and aggregated EATs. If different verifiers are employed for different EAT's in a nested or aggregated structure, how do the verifiers interoperate? Note that this may be better handled in the architecture doc, but the -01 version of the document treats the verifier as a monolith. I believe this is also the nature the comment by @nedmsmith<https://github.com/nedmsmith> above.\r\n\r\n\u2014\r\nYou are receiving this because you were mentioned.\r\nReply to this email directly, view it on GitHub<https://github.com/ietf-rats-wg/eat/issues/18?email_source=notifications&email_token=ABPMCSFGOFUATI4ZWIRC5ZDQA4XVNA5CNFSM4IFLG3C2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD2TWW5I#issuecomment-514288501>, or mute the thread<https://github.com/notifications/unsubscribe-auth/ABPMCSG3GPY76XZ3ZJFQR73QA4XVNANCNFSM4IFLG3CQ>.\r\n",
          "createdAt": "2019-07-24T14:14:03Z",
          "updatedAt": "2019-07-24T14:14:03Z"
        },
        {
          "author": "gmandyam",
          "authorAssociation": "COLLABORATOR",
          "body": "Depending on the disposition of https://github.com/ietf-rats-wg/eat/issues/27, this issue may become moot.  If the operating models section is removed, then the role of verification doesn't need to be discussed anywhere else in the document.",
          "createdAt": "2019-08-08T00:39:06Z",
          "updatedAt": "2019-08-08T00:39:06Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Can be closed because CWT and JWT cover this. Any additional coverage will go in the architecture or other documents.",
          "createdAt": "2019-10-04T16:24:36Z",
          "updatedAt": "2019-10-04T16:24:36Z"
        },
        {
          "author": "gmandyam",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing it.",
          "createdAt": "2019-10-04T16:43:51Z",
          "updatedAt": "2019-10-04T16:43:51Z"
        },
        {
          "author": "gmandyam",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that any residual verification procedures (i.e. those that are not already covered in RFC 8392 and RFC 7519) could go into an architecture doc.  The current architecture doc (-02 of https://datatracker.ietf.org/doc/draft-birkholz-rats-architecture/) does not have such a section yet, however.",
          "createdAt": "2019-10-04T16:52:03Z",
          "updatedAt": "2019-10-04T16:52:03Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU0NzA1Mjk4MTc=",
      "title": "Should ephemeral keys be allowed for signing EAT's?",
      "url": "https://github.com/ietf-rats-wg/eat/issues/19",
      "state": "OPEN",
      "author": "gmandyam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready to close"
      ],
      "body": "As per https://mailarchive.ietf.org/arch/msg/rats/d4GYkpwEMmh0VjD3Gmjd1h82Wpc -\r\n\r\n> \"The EAT is always signed by the attestation key material provisioned by the manufacturer.\"\r\n>This seems to prevent nested_eat use cases (e.g., cloud workloads with container/VM entities) where the outer EAT is signed with an \"ephemeral\" attestation key associated with the instance that is itself attested by the inner EAT signed with the AKM.  I suggest removing the sentence. ",
      "createdAt": "2019-07-19T20:29:19Z",
      "updatedAt": "2019-10-04T16:20:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SimonFrost-Arm",
          "authorAssociation": "NONE",
          "body": "Given the growing range of use cases for EAT, the alternative to manufacturer provisioned keys may not just be ephemeral keys, but could be keys obtained via an enrollment operation into some service and securely stored e.g. for anonymization reasons or to reflect a set of claims relevant to some service interaction. Agree that the simplest solution here may be to just drop this sentence but consider also whether the rest of the para, starting \"In all operating models, the manufacturer provisions some secret attestation key material...\" needs revising. I like the idea of a separate security section which could discuss the trust alternatives for the signing key.",
          "createdAt": "2019-07-22T13:32:03Z",
          "updatedAt": "2019-07-22T13:32:03Z"
        },
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "A stronger definition of what is meant by 'ephemeral' may be required. This relates to Issue 24.",
          "createdAt": "2019-07-22T18:52:32Z",
          "updatedAt": "2019-07-22T18:52:32Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Pretty sure the resolution here is to remove most of the operational and architectural model text so EAT is just claims definitions like CWT and JWT.\r\n\r\nDiscussion of key material can go in other documents or profiles.",
          "createdAt": "2019-10-01T13:46:05Z",
          "updatedAt": "2019-10-01T13:46:05Z"
        },
        {
          "author": "SimonFrost-Arm",
          "authorAssociation": "NONE",
          "body": "That would be an ideal resolution",
          "createdAt": "2019-10-01T15:34:08Z",
          "updatedAt": "2019-10-01T15:34:08Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "This can be closed because this will go into the architecture document and profiles.",
          "createdAt": "2019-10-04T16:19:57Z",
          "updatedAt": "2019-10-04T16:19:57Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU0NzA3OTgxOTQ=",
      "title": "Typo issues with -01",
      "url": "https://github.com/ietf-rats-wg/eat/issues/20",
      "state": "CLOSED",
      "author": "gmandyam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "They can be addressed in a -02 version.\r\n\r\nSec. 3:  Change \"\"It also mentions several claims defined by CWT and JWT are  particularly important for EAT.\" to 'that are particularly important'\r\n\r\nSec. 3:  Correct \"* All claims are optional * No claims are mandatory *.\"  Redundant.\r\n\r\nSec. 3.11:  \"Typically, one will be the device-wide EAT that is low to medium  security and another from a Secure Element or similar that is high security.\u201d  Consider changing \"Typically\" to \"For example\".\r\n\r\nSec. 3.11:  \"The contents of the \"eat\" claim must be a fully signed, ...\".  \"eat\" claim should be \"nested_eat\" claim. ",
      "createdAt": "2019-07-21T16:13:41Z",
      "updatedAt": "2019-07-22T17:52:37Z",
      "closedAt": "2019-07-22T17:52:36Z",
      "comments": [
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "I fixed the last two and pushed to GitHub.\r\n\r\nI like the first two the way they are.\r\n",
          "createdAt": "2019-07-22T17:23:00Z",
          "updatedAt": "2019-07-22T17:23:00Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Update: fixe the first one now that I see the missing \"that\".\r\n\r\nHave created a separate issue for claim optionality: https://github.com/ietf-rats-wg/eat/issues/23\r\n",
          "createdAt": "2019-07-22T17:52:36Z",
          "updatedAt": "2019-07-22T17:52:36Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU0NzA3OTgzODk=",
      "title": "RAND UEID's - minimum requirements to prevent clashes from different manufacturers",
      "url": "https://github.com/ietf-rats-wg/eat/issues/21",
      "state": "CLOSED",
      "author": "gmandyam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready to close"
      ],
      "body": "Current text (-01) does not state assumptions on rand generation that would be necessary to minimize the probability of collisions from different manufacturers.  This could be added to the Security Considerations section.",
      "createdAt": "2019-07-21T16:15:51Z",
      "updatedAt": "2020-11-03T18:34:58Z",
      "closedAt": "2020-11-03T18:34:58Z",
      "comments": [
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "An attacker might purposefully reuse an existing EUID (random or not). The security of attestation should not depend on a convention for whether the generation algorithm includes entropy. Even if values are guessable, there should be an understanding by the Verifier for how to detect that the value is authentic / spoofed. The entity (vendor) creating the EUID is not motivated to issue duplicates. Whether they select a method based on entropy or assigned values should be a vendor specific choice (IMO).",
          "createdAt": "2019-07-22T18:42:48Z",
          "updatedAt": "2019-07-22T18:42:48Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "@nedmsmith Addressing your comment from July 22, 2019. The relying party has to trust the UEID based on the fact that it was signed by the attester. They trust the attester because of endorsements. There's nothing more that can be done.\r\n\r\nThe vendor can choose the type they want, random, MAC address.... They can even switch from one day to the next.",
          "createdAt": "2020-02-29T16:57:18Z",
          "updatedAt": "2020-02-29T16:57:18Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this is fixed with #35",
          "createdAt": "2020-02-29T16:57:31Z",
          "updatedAt": "2020-02-29T16:57:31Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU0NzA4MDEwMTk=",
      "title": "Sec. 3.7.6 (-01):  Should debug disable states be an array or a choice option?",
      "url": "https://github.com/ietf-rats-wg/eat/issues/22",
      "state": "CLOSED",
      "author": "gmandyam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready to close"
      ],
      "body": "Sec. 2.2.2 of RFC 8610 allows for a choice expression based on a '/' delimiter between options.  In order to avoid expression of potentially conflicting debug disable states (e.g. debug full permanent disable being true while debug disabled since boot being false), this could be an alternative.",
      "createdAt": "2019-07-21T16:45:47Z",
      "updatedAt": "2020-11-03T18:34:28Z",
      "closedAt": "2020-11-03T18:34:28Z",
      "comments": [
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "I think I agree with this with the concept being that you claim the highest level of debug disable that is true for the device at the moment. That means selecting a higher level of debug disabling requires all the lower levels of debug disabling are true. \r\n",
          "createdAt": "2019-10-04T17:48:24Z",
          "updatedAt": "2019-10-04T17:48:24Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed with #36 ",
          "createdAt": "2020-03-19T18:09:02Z",
          "updatedAt": "2020-03-19T18:09:14Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU0NzEyMjI1NjM=",
      "title": "Claims optionality and profiles",
      "url": "https://github.com/ietf-rats-wg/eat/issues/23",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready to close"
      ],
      "body": "Current text:\r\n* All claims are optional\r\n* No claims are mandatory\r\n* All claims that are not understood by implementations MUST be ignored\r\n\r\n\u2022Should profiles be allowed to override this?\r\n\u2022Should there be text that says they can?\r\n\u2022How does this relate to JWT/CWT optionality?",
      "createdAt": "2019-07-22T17:49:50Z",
      "updatedAt": "2019-10-04T16:18:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "Verifier policies ultimately determine which claims matter and how to respond appropriately. Saying \"all claims are optional\" is different from saying \"all claims not understood by implementations MUST be ignored\". The latter potentially contradicts verifier policy that may NOT wish to process unknown claims as these may have obligatory requirements to protecting the confidentiality or integrity.\r\n\r\nDefinition of Verifier policies may be out of scope for RATS, though it should be anticipated that Verifiers have them.",
          "createdAt": "2019-07-22T18:49:12Z",
          "updatedAt": "2019-07-22T18:49:12Z"
        },
        {
          "author": "SimonFrost-Arm",
          "authorAssociation": "NONE",
          "body": "The intent of proposing the use of a referenced profile in draft-tschofenig-rats-psa-token is that it would be a description of the rules applied by the attesting implementation to the production of the EAT. A verifier would use this document to understand how to implement sufficient verification. The document would be normally be human readable rather than machine readable, though the latter case is not eliminated.\r\nThe profile will contain a full description of the standard claims and custom claims included, their usage (incl optionality), expected token signing, and any any verification specifics e.g. token structure such as submod usage.",
          "createdAt": "2019-07-23T09:51:57Z",
          "updatedAt": "2019-07-23T09:51:57Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "CWT text seems pretty good:\r\n>Specific applications of CWTs will require implementations to\r\n   understand and process some claims in particular ways.  However, in\r\n   the absence of such requirements, all claims that are not understood\r\n   by implementations MUST be ignored.",
          "createdAt": "2019-07-23T19:05:44Z",
          "updatedAt": "2019-07-23T19:05:44Z"
        },
        {
          "author": "SimonFrost-Arm",
          "authorAssociation": "NONE",
          "body": "I agree that the CWT text makes sense. \r\nIn trying to answer your queries posed in the initial Issue it seems to raise the question of whether there should be a mechanism for an implementation to declare the exact nature of its operation. What I probably should have added to my comment above is the suggestion that EAT should include a standard claim for 'profile' which would support such a mechanism. Previously that seemed supplementary to this specific issue but I'm not sure by what other form of submission you would like that proposal?\r\n",
          "createdAt": "2019-07-24T09:10:40Z",
          "updatedAt": "2019-07-24T09:10:40Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "We can close this because there is consensus that the CWT and JWT text for optionality is fine and because there is a separate issue for profiles, #32",
          "createdAt": "2019-10-04T16:18:39Z",
          "updatedAt": "2019-10-04T16:18:39Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "MDU6SXNzdWU0NzEyNDk0ODg=",
      "title": "Should there be key usage constraints for attestation?",
      "url": "https://github.com/ietf-rats-wg/eat/issues/24",
      "state": "OPEN",
      "author": "nedmsmith",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It isn't clear whether an key used for attestation is restricted to signing evidence that is controlled by a trusted environment. The risk of not having constraints is the key may be subject to a confused deputy attack where claims are presented as opaque data that then receive a signature and a verifier presumes the attester made the claims. \r\n\r\nShould it be mandatory for EAT claims to reside within the security perimeter of a trusted environment such as a TEEP TEE / TEEP Agent?",
      "createdAt": "2019-07-22T18:33:52Z",
      "updatedAt": "2019-10-11T17:02:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we must allow EATs to be generated in any environment, even Android apps, Windows Apps and such. \r\n\r\nSigning key protection requirements are for user case policy documents, certification and such. Probably these should come from organizations like FIDO, GP and TCG, not IETF. \r\n\r\nSimilarly, whether the key is used to sign attestation and whether the all the things is signs are as authentic as expected is a policy thing. \r\n\r\nHowever, I DO think EAT should allow signing and labeling of claims from outside the main protection boundary. This is in the current draft as a \"submod\". Note that this is not pegging security to any absolute level, just indicating some claims have different security than others.\r\n\r\n",
          "createdAt": "2019-07-23T13:50:34Z",
          "updatedAt": "2019-07-23T13:50:34Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Where you thinking of defining a new key use type for attestation? That could be in PKIX and/or COSE and/or JSON Web Key.\r\n\r\nAlternatively it could be a security recommendation that attestation keys are only used for attestation.\r\n\r\nFIDO has this notion of separation. FIDO has some enforcement through its certification program. IETF has no such program, so the best IETF can do is text in the security considerations section.\r\n",
          "createdAt": "2019-10-11T17:02:03Z",
          "updatedAt": "2019-10-11T17:02:03Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWU0NzgxOTUwNzc=",
      "title": "Boot state text corrections:  ver. -01",
      "url": "https://github.com/ietf-rats-wg/eat/issues/25",
      "state": "CLOSED",
      "author": "gmandyam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready to close"
      ],
      "body": "Sec.'s 3.7.3, 3.7.4 and 3.7.5 start out with the term \"this claim\".  These are actually not claims as per the definition in Sec. 3.7, but boolean values included in the boot_state claim.    ",
      "createdAt": "2019-08-08T00:27:48Z",
      "updatedAt": "2020-11-03T18:25:50Z",
      "closedAt": "2020-11-03T18:25:50Z",
      "comments": [
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed. Wording should be fixed.",
          "createdAt": "2019-10-04T16:34:09Z",
          "updatedAt": "2019-10-04T16:34:09Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #36 ",
          "createdAt": "2020-02-29T16:48:43Z",
          "updatedAt": "2020-02-29T16:48:43Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU0NzgxOTU1MDI=",
      "title": "The list of claims in 4.5 does not match the list in 4.4.1",
      "url": "https://github.com/ietf-rats-wg/eat/issues/26",
      "state": "OPEN",
      "author": "gmandyam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-08-08T00:29:46Z",
      "updatedAt": "2019-10-04T16:42:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, submods is missing.",
          "createdAt": "2019-10-04T16:42:47Z",
          "updatedAt": "2019-10-04T16:42:47Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU0NzgxOTcwMDU=",
      "title": "Remove Sec. 1.3 EAT Operating Models (ver. -01)",
      "url": "https://github.com/ietf-rats-wg/eat/issues/27",
      "state": "OPEN",
      "author": "gmandyam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "2 reasons:\r\n\r\na) Neither RFC 8392 (CWT) nor RFC 7519 (JWT) have operational models.  Since EAT is derived from these specifications, it would be desirable to maintain consistency.\r\n\r\nb) This topic is better covered in an architecture specification. ",
      "createdAt": "2019-08-08T00:37:34Z",
      "updatedAt": "2020-02-29T16:58:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Can be closed because the plan is to move this to architecture",
          "createdAt": "2019-10-04T16:21:23Z",
          "updatedAt": "2019-10-04T16:21:23Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWU1MDA5MTI0MzQ=",
      "title": "Add a claim definition for SW inventory",
      "url": "https://github.com/ietf-rats-wg/eat/issues/30",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "new claim"
      ],
      "body": "The claim would list SW on the entity. It would probably include name the name and version of each SW component.  This is probably a complicated claim to define.\r\n\r\nSee also issue #31 \r\n\r\nThis might include a signer ID like https://tools.ietf.org/html/draft-tschofenig-rats-psa-token-02 does",
      "createdAt": "2019-10-01T13:53:31Z",
      "updatedAt": "2019-11-20T23:58:00Z",
      "closedAt": null,
      "comments": [
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "There was good humming in favor of this in Singapore.\r\n\r\nThis seems like the obvious choice: https://tools.ietf.org/html/draft-ietf-sacm-coswid-13\r\n\r\nI'm planning to make a pull request",
          "createdAt": "2019-11-20T23:58:00Z",
          "updatedAt": "2019-11-20T23:58:00Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "MDU6SXNzdWU1MDA5MTU2MDg=",
      "title": "Add a claim definition for SW measurement and/or integrity status",
      "url": "https://github.com/ietf-rats-wg/eat/issues/31",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "new claim"
      ],
      "body": "This claim would list measurements made on parts of the entity. Typically a measurement is a hash of some region. This may by SW component or it may be more of a run time integrity measuring memory images.\r\n\r\nFor TEE-based implementations, it is possible to evaluate the measurement on the device and only list the integrity status as a Boolean rather than a measurement. \r\n\r\nSee also issue #30 ",
      "createdAt": "2019-10-01T13:58:09Z",
      "updatedAt": "2019-12-03T18:59:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "The claim should either be a measurement claim or a boolean claim corresponding to some sort of status being asserted. There shouldn't be an assumption that all TEEs work a certain way. The TEE status claim should be discussed separately from this claim IMO.",
          "createdAt": "2019-12-03T18:59:21Z",
          "updatedAt": "2019-12-03T18:59:21Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWU1MDA5NDg2MDk=",
      "title": "Add claim to name profile used by the token",
      "url": "https://github.com/ietf-rats-wg/eat/issues/32",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "new claim"
      ],
      "body": "Profiles are very concrete, use case specific, documents that say which claims are mandatory and which are optional and other.  For example there might be a profile for payments, one for automotive, one for a specific IoT industry and such. This claim would name the profile in use for this token, perhaps with a reference to its defining document. \r\n\r\nThis is used in https://tools.ietf.org/html/draft-tschofenig-rats-psa-token-02",
      "createdAt": "2019-10-01T14:47:57Z",
      "updatedAt": "2019-10-07T13:48:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "SimonFrost-Arm",
          "authorAssociation": "NONE",
          "body": "Some further background on the profiles document, from the discussions that lead to its inclusion in the PSA token doc.  The intent behind a profile document is that its a (human readable) description of the token. It would normally contain:\r\n - Details of the token signing\r\n- The list of expected standard EAT claims used\r\n- The list of any Custom claims used\r\n- The status of the claims (optional / mandatory / recommended)\r\n- A full description of the semantic usage of the claims.\r\n- Any information required to perform verification of claims.\r\n- Any expected structure (e.g. submods) that may need to be understood to interpret the token\r\n\r\nThere is a question on how profiles would be located if not just assumed to be informational to an existing RP/supplier relationship. One possibility might be to form a new IANA registry containing a mapping of profiles names (as used in this claim) to locations. Another might be for this claim structure to either be a text string identifying the document or a URL to the location.",
          "createdAt": "2019-10-03T08:57:22Z",
          "updatedAt": "2019-10-03T08:57:22Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWU1MDA5NDk0Mjk=",
      "title": "HW Version claim",
      "url": "https://github.com/ietf-rats-wg/eat/issues/33",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "new claim"
      ],
      "body": "https://tools.ietf.org/html/draft-tschofenig-rats-psa-token-02 defines this in terms of EAN-13. This seems like a good thing to do.",
      "createdAt": "2019-10-01T14:49:16Z",
      "updatedAt": "2019-10-07T13:50:48Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWU1MDA5NTEyODU=",
      "title": "Add boot seed claim",
      "url": "https://github.com/ietf-rats-wg/eat/issues/34",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "new claim"
      ],
      "body": "This is a random value that is generated each time the entity boots. \r\n\r\nhttps://tools.ietf.org/html/draft-tschofenig-rats-psa-token-02 defines this.",
      "createdAt": "2019-10-01T14:52:09Z",
      "updatedAt": "2019-12-03T19:03:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "It should be clearly documented that the seed value isn't a secret (if that is the case?). If so, then it would be more correct to call it a 'salt' rather than a 'seed'. A seed that seeds a PRNG or a key gen function is a secret since PRNGs have deterministic results given the same seed. ",
          "createdAt": "2019-12-03T19:03:07Z",
          "updatedAt": "2019-12-03T19:03:07Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU1MDc5NDMwODE=",
      "title": "Sort out cti, jti and nonce claims from CWT and JWT",
      "url": "https://github.com/ietf-rats-wg/eat/issues/37",
      "state": "CLOSED",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready to close"
      ],
      "body": "Which CWT / JWT field is really the nonce?",
      "createdAt": "2019-10-16T15:54:41Z",
      "updatedAt": "2020-11-03T18:26:28Z",
      "closedAt": "2020-11-03T18:26:28Z",
      "comments": [
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in #42",
          "createdAt": "2020-02-29T17:02:39Z",
          "updatedAt": "2020-02-29T17:02:39Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWU1MDc5NDQ0NzU=",
      "title": "OEM claim improvements",
      "url": "https://github.com/ietf-rats-wg/eat/issues/38",
      "state": "CLOSED",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready to close"
      ],
      "body": "Need references to IEEE OUI and to fill in details",
      "createdAt": "2019-10-16T15:57:03Z",
      "updatedAt": "2020-11-03T18:26:14Z",
      "closedAt": "2020-11-03T18:26:14Z",
      "comments": [
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #41 ",
          "createdAt": "2020-02-29T16:59:07Z",
          "updatedAt": "2020-02-29T16:59:07Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWU1MDc5NDQ5NDc=",
      "title": "Origination claim needs refinement",
      "url": "https://github.com/ietf-rats-wg/eat/issues/39",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-10-16T15:57:49Z",
      "updatedAt": "2019-10-16T15:57:49Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWU1MDc5NDU1MTg=",
      "title": "Add examples of submod and nested EAT tokens",
      "url": "https://github.com/ietf-rats-wg/eat/issues/40",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-10-16T15:58:50Z",
      "updatedAt": "2019-10-16T15:58:50Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 44,
      "id": "MDU6SXNzdWU1MTYxNzgzMTU=",
      "title": "Claims that go from verifier to relying party",
      "url": "https://github.com/ietf-rats-wg/eat/issues/44",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "EAT is used to convey claims from the entity / device to the verifier, but it can also be used to convey the output of the verifier to the relying party.\r\n\r\nFor example, the input to the verifier may be software measurements. The output of the verifier might be a Boolean that the measurements were correct. \r\n\r\nAlso, some implicit claims might be made explicit. For example, if the verifier knows that the device will never send an attestation is the boot and debug state are not locked down, then the verifier can add those claims.",
      "createdAt": "2019-11-01T15:20:55Z",
      "updatedAt": "2019-11-01T15:20:55Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWU1MjY5NDYxMjM=",
      "title": "Align oemid and UEID with IDevID?",
      "url": "https://github.com/ietf-rats-wg/eat/issues/45",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "RIV uses IDevID which has a manufacturer and serial number. If this goes into attestation result then maybe it should be expressible in EAT.\r\n",
      "createdAt": "2019-11-22T02:15:32Z",
      "updatedAt": "2019-11-22T02:15:32Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWU1MjcyODIzMDc=",
      "title": "(Signed) CoSWID, (Signed) ISO SWID & SUIT Manifest Claims",
      "url": "https://github.com/ietf-rats-wg/eat/issues/46",
      "state": "OPEN",
      "author": "henkbirkholz",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-22T16:06:16Z",
      "updatedAt": "2019-11-24T15:55:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "henkbirkholz",
          "authorAssociation": "COLLABORATOR",
          "body": "Proposal:\r\n\r\nWrite-up for Claim Definitions for inclusion in drat-ietf-rats-eat (OR separate EAT flavor I-D as on option to expedite wglc/adoption process):\r\n\r\nAt minimum, nine additional CWT/EAT Claims MUST be defined.\r\n\r\n1. Unsigned CoSWID Evidence Claim (including corresponding Security Consideration)\r\n2. Signed CoSWID Evidence Claim including corresponding COSE guidance and Security Consideration)\r\n3. Unsigned CoSWID Payload Claim (including at minimum corresponding Security Consideration)\r\n4. Signed CoSWID Payload Claim (including at minimum corresponding COSE guidance and Security Consideration)\r\n5. Unsigned ISO SWID Evidence Claim (including at minimum corresponding Security Consideration)\r\n6. Signed ISO SWID Evidence Claim (including at minimum corresponding NIST SR 8060 guidance and Security Consideration)\r\n7. Unsigned ISO SWID Payload Claim (including at minimum corresponding Security Consideration)\r\n8. Signed ISO SWID Evidence Claim (including at minimum corresponding NIST SR 8060 guidance and Security Consideration), ad\r\n9. SUIT Manifest Claim (potentially signed and including corresponding Security Consideration)\r\n\r\nDave Waltermire and Henk Birkholz discussed this proposal with respect to:\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/sacm/qrliM4reggLvDu0ft9ianypYFLM\r\nand\r\nhttps://mailarchive.ietf.org/arch/msg/rats/HKUTLMy843rcnhdjnLvnLx9NUuE\r\nrespectively.\r\n\r\nThe proposal includes the notion to avoid blocking or delaying changes to CBOR tag & content-type definitions of corresponding I-D via additions to the EAT Claim Definition set. Therefore expediting related I-D progress and assuring interoperability between SUIT, SACM & RATS at the same time.",
          "createdAt": "2019-11-22T16:30:46Z",
          "updatedAt": "2019-11-22T16:30:46Z"
        },
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "What is the difference between \"Evidence\" claims and \"Payload\" claims?",
          "createdAt": "2019-11-22T22:37:00Z",
          "updatedAt": "2019-11-22T22:37:00Z"
        },
        {
          "author": "henkbirkholz",
          "authorAssociation": "COLLABORATOR",
          "body": "Both term in the context of *SWID are defined here:\r\n\r\nhttps://tools.ietf.org/html/draft-ietf-sacm-coswid-13#section-2.3\r\n\r\nthere is an corresponding answer with more details in the rats email list here:\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/rats/kn_fOc0qofTvyKlUvod1BSgpO3o",
          "createdAt": "2019-11-24T15:55:23Z",
          "updatedAt": "2019-11-24T15:55:23Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "MDU6SXNzdWU1NjM5ODU4Njg=",
      "title": "Disallow floating point time stamps in EAT?",
      "url": "https://github.com/ietf-rats-wg/eat/issues/49",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The nbf, exp and iat claims in CWT are allowed to be floating point. EAT inherits from them.\r\n\r\nFloating point is not universally supported by CPUs, particularly small ones for IoT. Even if the CPU supports it, the compiler and OS might not (I\u2019ve seen this happen once).\r\n\r\nI don\u2019t think fractional seconds are of any value for these claims, so we are forcing EAT decoders to support this for no good reason. I\u2019m not sure why CWT allowed floating point for these claims other than just inheriting from the CBOR epoch time format.\r\n\r\nIt is possible to use SW to decode a float and turn it into an integral value, but that is not fun to write and seems a waste.\r\n\r\nI\u2019d like to specify in EAT that floating point is not allowed for these claims.\r\n\r\n(Separately, we do need floating point for GPS location, but that claim will be used much less frequently and it is a good reason for using floating point).",
      "createdAt": "2020-02-12T13:02:55Z",
      "updatedAt": "2020-02-12T13:02:55Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 50,
      "id": "MDU6SXNzdWU1NjQ2NTUwNjY=",
      "title": "Are latitude and longitude optional in location claim?",
      "url": "https://github.com/ietf-rats-wg/eat/issues/50",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Clearly most part of the location claim are optional. For example you don't have to specify speed.  Should latitude and longitude also be optional? Can you just specify altitude if you want to?\r\n",
      "createdAt": "2020-02-13T12:37:39Z",
      "updatedAt": "2020-02-13T12:37:39Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 51,
      "id": "MDU6SXNzdWU1NjQ2NjY5Mzk=",
      "title": "Should issuer, subject and audience claims allow URI tag?",
      "url": "https://github.com/ietf-rats-wg/eat/issues/51",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "RFC8392 doesn't say whether the URI tag #6.32 should or should not be used on the issuer, subject and audience claims. Without it the decoder would use a URI syntax matcher to decide between it being text or a URI.",
      "createdAt": "2020-02-13T13:00:19Z",
      "updatedAt": "2020-02-13T13:00:19Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU1NjQ2OTk0NzU=",
      "title": "Sort out CWT and COSE tag usage",
      "url": "https://github.com/ietf-rats-wg/eat/issues/53",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When should the CWT and COSE tags be used with an EAT?",
      "createdAt": "2020-02-13T13:56:06Z",
      "updatedAt": "2020-02-13T13:56:06Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 54,
      "id": "MDU6SXNzdWU1NjY4OTk3Mzc=",
      "title": "Accommodate \"GP unendorsed\" tokens",
      "url": "https://github.com/ietf-rats-wg/eat/issues/54",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Consider making an EAT a \"CWT Claims Set\" as defined in CWT (and JWT) to accommodate GP's desired for unsigned tokens.",
      "createdAt": "2020-02-18T13:39:54Z",
      "updatedAt": "2020-02-18T13:39:54Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 55,
      "id": "MDU6SXNzdWU1NzIyNzg2NjE=",
      "title": "Clarify on seclevel/security-level in example",
      "url": "https://github.com/ietf-rats-wg/eat/issues/55",
      "state": "CLOSED",
      "author": "gmandyam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Re:  https://tools.ietf.org/html/draft-ietf-rats-eat-03#appendix-A.2\r\n\r\n'seclevel' is showing up in the example.  Two issues:\r\n\r\na) seclevel is actually security-level in the current doc.\r\n\r\nb) For a submod is not providing attestation info in the form of an (endorsed) EAT, is there any value in providing security-level?  If it is there, what entity is performing the security level assessment?",
      "createdAt": "2020-02-27T18:42:27Z",
      "updatedAt": "2020-03-28T21:10:04Z",
      "closedAt": "2020-03-28T21:10:04Z",
      "comments": [
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed a). \r\n\r\nb) is the same as #58",
          "createdAt": "2020-03-19T18:19:40Z",
          "updatedAt": "2020-03-19T18:19:40Z"
        },
        {
          "author": "gmandyam",
          "authorAssociation": "COLLABORATOR",
          "body": "Close and will track via https://github.com/ietf-rats-wg/eat/issues/58",
          "createdAt": "2020-03-28T21:10:03Z",
          "updatedAt": "2020-03-28T21:10:03Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "MDU6SXNzdWU1NzQ5NDEwMDI=",
      "title": "Consider 'context' claim",
      "url": "https://github.com/ietf-rats-wg/eat/issues/57",
      "state": "OPEN",
      "author": "gmandyam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://tools.ietf.org/html/draft-mandyam-rats-qwestoken-00#section-3.3\r\n\r\nAn optional context claim can provide information on intended usage to the recipient of the attestation token.",
      "createdAt": "2020-03-03T21:01:32Z",
      "updatedAt": "2020-03-03T21:01:32Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 58,
      "id": "MDU6SXNzdWU1ODM5NTk3MzI=",
      "title": "Who assigns the security level of a submodule?",
      "url": "https://github.com/ietf-rats-wg/eat/issues/58",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-18T19:39:58Z",
      "updatedAt": "2020-03-18T19:39:58Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWU2NDM4Nzg3ODE=",
      "title": "EAT document should say it can be used for Attestation Results",
      "url": "https://github.com/ietf-rats-wg/eat/issues/63",
      "state": "OPEN",
      "author": "mcr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/ietf-rats-wg/architecture/issues/92 topic 3 has some points about EAT.\r\n\r\nTopic 3: EAT. If accurate, I'd like to see a clear acknowledgement that the Verifier may need to act as an Attester for the Relying Party since I'd like to then see specifically how the IETF EAT specification covers this circumstance. In other words, for an EAT that represents an AttestationResult, would the Evidence for the Verifier be embedded or discovered? If embedded, how are submods distinguished for the Verifier's Evidence versus the AttestationResult's embedded claims, including nested EAT's?",
      "createdAt": "2020-06-23T14:15:00Z",
      "updatedAt": "2020-06-26T16:15:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gkostal",
          "authorAssociation": "NONE",
          "body": "@mcr , thanks for opening this issue in EAT based on a portion of an issue I opened against the architecture document.  \r\n\r\nI would title this issue ***\"EAT guidance on how to share the information used to establish trust of Verifier by a Relying Party?\"***\r\n\r\nUsing the nomenclature of the IETF RATS Architecture document, I believe the following is true:\r\n1. EAT defines the claims used as \"Evidence\" or \"Attestation Results\" in the [RATS architecture diagram](https://www.ietf.org/id/draft-ietf-rats-architecture-04.html#name-architectural-overview)\r\n1. The \"Verifier\" in the RATS architecture can be a separate entity from the Relying Party.  Hence, it's necessary that the Verifier be able to provide information to the Relying Party to establish this trust.  The [Trust Model](https://www.ietf.org/id/draft-ietf-rats-architecture-04.html#name-trust-model) section in the RATS Architecture document discusses this requirement.\r\n1. This information may take the form of \"Evidence\" describing the Verifier's execution environment, which is distinct from the \"Evidence\" it analyzes to produce a specific \"Attestation Result\".\r\n\r\nMany (most? all?) \"Verifiers\" will need to share this trust establishing information with Relying Parties.  A Relying Party may work with more than one \"Verifier\".  Is it in scope for EAT to give some guidance on how a Verifier shares this information?  If not EAT, is it (or should it be) in scope for any other standardization process?  Left unaddressed, each Verifier will implement an ad-hoc mechanism, leaving Relying Parties unable to trust EAT tokens without first writing vendor specific logic for each Verifier they work with.\r\n",
          "createdAt": "2020-06-26T16:15:50Z",
          "updatedAt": "2020-06-26T16:15:50Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "MDU6SXNzdWU2NDQ3ODY3OTQ=",
      "title": "looking for example of EAT with PCR quote",
      "url": "https://github.com/ietf-rats-wg/eat/issues/64",
      "state": "OPEN",
      "author": "mcr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It would be good to have a clear example on how to carry a TPM-2 style PCR Quote in as an example of evidence carried by EAT.\r\n",
      "createdAt": "2020-06-24T17:31:11Z",
      "updatedAt": "2020-07-01T22:30:26Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tomoveu",
          "authorAssociation": "NONE",
          "body": "Indeed @mcr . Thank you for rising this issue. Would be great to have an example how a TPM2 Quote fits with EAT or RATS in general. Open-source code that we can see and test.",
          "createdAt": "2020-07-01T17:33:00Z",
          "updatedAt": "2020-07-01T17:33:00Z"
        },
        {
          "author": "henkbirkholz",
          "authorAssociation": "MEMBER",
          "body": "Hi Dimi, \r\nwith respect to running code, at the moment we decompose TPM structures in https://github.com/Fraunhofer-SIT/charra\r\n\r\nThe corresponding CBOR items are currently composed according to the following CDDL spec:\r\n\r\nhttps://ietf-rats.github.io/draft-birkholz-rats-reference-interaction-model/draft-birkholz-rats-reference-interaction-model.html#section-appendix.a\r\n\r\nThe arrays used include label notation for the human reader. These can be used 1:1 as Claim definitions for EAT today (via a nested Claims Set) called tpm2-quote-request and tpm2-quote response, for example.\r\n\r\nIf there is demand for that, it would be relatively straight forward for us to add corresponding CDDL in the EAT style that  to the I-D. Everything needed is already defined in that section.\r\n\r\n",
          "createdAt": "2020-07-01T17:43:15Z",
          "updatedAt": "2020-07-01T17:43:15Z"
        },
        {
          "author": "tomoveu",
          "authorAssociation": "NONE",
          "body": "Thank you, Henk!\r\n\r\nHere is the recording of your explanation on the TPMdev call - [https://developers.tpm.dev/posts/7112151](https://developers.tpm.dev/posts/7112151) Made things very clear.\r\n\r\nThe link to the document(Appendix A) also helped a lot. What exactly do you think can go in Appendix B as a format regarding TPM2 Quote & EAT?\r\n\r\nps: I tried tagging you on the post in the forum, but it seems you do not have an account there or maybe you use a nickname and I could not recognize you",
          "createdAt": "2020-07-01T22:28:27Z",
          "updatedAt": "2020-07-01T22:30:26Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWU3MjQ5NTUxNjg=",
      "title": "nested token submods should be byte-string wrapped",
      "url": "https://github.com/ietf-rats-wg/eat/issues/65",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now, the second type of submod, the embedding of a full signed EAT token inside surrounding token is \"direct\".\r\n\r\nI think it needs to be wrapped in a byte string to make it reasonable to implement. When decoding the surrounding token, the nested token will be returned as a byte string that can be easily passed to the COSE/CWT/EAT decoder as these will typically take a byte string as input. \r\n\r\nIf it is not a byte string, then you have to convince the CBOR decoder to return the CWT Tag as a byte string even though it is not a byte string or the same or related instance of the CBOR decoder used to decode the outside EAT must be used to decode the inside EAT.\r\n\r\nNo semantics would change. This is only for a practical consideration of the APIs used for decoding CBOR, COSE, CWT and EAT.",
      "createdAt": "2020-10-19T20:34:05Z",
      "updatedAt": "2020-10-19T20:34:05Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk3NjAwNzMy",
      "title": "Create draft-ietf-mandyam-eat.md",
      "url": "https://github.com/ietf-rats-wg/eat/pull/1",
      "state": "MERGED",
      "author": "gmandyam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Seeding repo",
      "createdAt": "2018-06-27T02:31:36Z",
      "updatedAt": "2018-06-27T17:55:36Z",
      "closedAt": "2018-06-27T17:55:36Z",
      "mergedAt": "2018-06-27T17:55:36Z",
      "mergedBy": "laurencelundblade",
      "comments": [],
      "reviews": [],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "69738ac44f179863fea75a0cfa10e7335aae1e13",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "9b927bfcb8cce27338e5e60794539ebc689c7b3d",
      "mergeCommit": {
        "oid": "69765a42137ecc476e9fc15f9c83f87794882cef"
      }
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNTExNDIx",
      "title": "First draft of CBOR interop section",
      "url": "https://github.com/ietf-rats-wg/eat/pull/5",
      "state": "MERGED",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "CBOR has a lot of different data type and for each type there are encoding variations. In order for EAT to have good interoperability, there has to be a specification for what types and variants to use. \r\n\r\n(Seems to me that other CBOR-based protocols like COSE and CWT should have similar).\r\n",
      "createdAt": "2018-07-15T19:19:21Z",
      "updatedAt": "2018-11-19T15:20:21Z",
      "closedAt": "2018-11-19T15:20:20Z",
      "mergedAt": "2018-11-19T15:20:20Z",
      "mergedBy": "gmandyam",
      "comments": [],
      "reviews": [],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "69765a42137ecc476e9fc15f9c83f87794882cef",
      "headRepository": "ietf-rats-wg/eat",
      "headRefName": "CBOR-Interop",
      "headRefOid": "0a6c332301667942aa53d232a0710db863dbee47",
      "mergeCommit": {
        "oid": "d43880a9817a8f48ca1ec6fda3ce230396feb277"
      }
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIxMTk3NDU1",
      "title": "Fix for some typos",
      "url": "https://github.com/ietf-rats-wg/eat/pull/6",
      "state": "MERGED",
      "author": "mathias-arm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-08T17:56:01Z",
      "updatedAt": "2018-11-16T02:07:59Z",
      "closedAt": "2018-11-16T02:07:54Z",
      "mergedAt": "2018-11-16T02:07:54Z",
      "mergedBy": "gmandyam",
      "comments": [
        {
          "author": "gmandyam",
          "authorAssociation": "COLLABORATOR",
          "body": "@mathias-arm \r\n\r\nThanks for providing this.  It is now merged.",
          "createdAt": "2018-11-16T02:07:59Z",
          "updatedAt": "2018-11-16T02:07:59Z"
        }
      ],
      "reviews": [],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "69765a42137ecc476e9fc15f9c83f87794882cef",
      "headRepository": "mathias-arm/eat",
      "headRefName": "master",
      "headRefOid": "238a38219eaf6a8b5145ec60baba5af9345f48b7",
      "mergeCommit": {
        "oid": "32734ed3cd9db3843fb6a92b3acf340df18ac5a4"
      }
    },
    {
      "number": 7,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcwOTM1NzIy",
      "title": "Added Claims Characteristics section",
      "url": "https://github.com/ietf-rats-wg/eat/pull/7",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-04-16T14:28:45Z",
      "updatedAt": "2020-04-14T19:48:38Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "henkbirkholz",
          "authorAssociation": "COLLABORATOR",
          "body": "I would recommend to remove the \"Some examples of profiles that may come to exist:\" content. A specification or even proposed standard is not a good place for listing \"work that may or may not be done\", I think. Other SDO actually forbid this type of content rather strictly. I am not sure what the exact IETF rules are, tbh.",
          "createdAt": "2019-11-27T21:00:04Z",
          "updatedAt": "2019-11-27T21:00:04Z"
        },
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "I assert that existence in a specification justifies its existence! ",
          "createdAt": "2020-01-06T22:21:24Z",
          "updatedAt": "2020-01-06T22:21:24Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "I take Ned's point that it is a bit circular to justify the existence of claims that have been agreed upon in the standard. However I think the text is important and helpful and should be in the document somewhere.\r\n\r\nOne possibility is the section for IANA as advice for claims registration. This is still odd though since there is no EAT IANA registry as we re use CWT.\r\n",
          "createdAt": "2020-02-04T18:44:52Z",
          "updatedAt": "2020-02-04T18:44:52Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "@henkbirkholz on the examples to be built, I agree that this is probably not the right way to frame it. What about just listing the as examples with out the \"may come to exist\" part?",
          "createdAt": "2020-02-04T19:47:22Z",
          "updatedAt": "2020-02-04T19:47:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEzMzM0NjU2",
          "commit": {
            "abbreviatedOid": "c72786f"
          },
          "author": "setrofim",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-07T13:26:23Z",
          "updatedAt": "2019-11-07T13:26:24Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nClaims should not be defined such they are specific to a chip or\r\n```\r\nor\r\n```suggestion\r\nClaims should be defined such they are not specific to any chip or\r\n```",
              "createdAt": "2019-11-07T13:26:23Z",
              "updatedAt": "2020-04-14T19:48:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEzNDEyMzc4",
          "commit": {
            "abbreviatedOid": "c72786f"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This looks like the wrong file (draft-ietf-mandyam-eat.md instead of draft-ietf-rats-eat.md)?",
          "createdAt": "2019-11-07T15:15:11Z",
          "updatedAt": "2019-11-07T15:15:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEzNDIyNDUw",
          "commit": {
            "abbreviatedOid": "c72786f"
          },
          "author": "SimonFrost-Arm",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-07T15:28:11Z",
          "updatedAt": "2019-11-07T15:28:12Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Typo:  claims should +use+ already standardized",
              "createdAt": "2019-11-07T15:28:12Z",
              "updatedAt": "2020-04-14T19:48:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEzNDI1MjAx",
          "commit": {
            "abbreviatedOid": "c72786f"
          },
          "author": "SimonFrost-Arm",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-07T15:31:25Z",
          "updatedAt": "2019-11-07T15:31:26Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Add comment to the effect that proprietary claims should not be used instead of an equivalent standard claims unless the implementation is significantly different?",
              "createdAt": "2019-11-07T15:31:26Z",
              "updatedAt": "2020-04-14T19:48:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4OTMwOTkx",
          "commit": {
            "abbreviatedOid": "c72786f"
          },
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-06T22:19:58Z",
          "updatedAt": "2020-01-06T22:19:59Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Shouldn't the language be \"...such THAT they...\"?\r\n\r\nNot sure why the EAT draft should give guidance on what belongs as a claim (or not). Doesn't the existence of the claim in the spec resolve whether or not it should exist?",
              "createdAt": "2020-01-06T22:19:58Z",
              "updatedAt": "2020-04-14T19:48:38Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "aac5de214068993208b41066f1717222abde6114",
      "headRepository": "ietf-rats-wg/eat",
      "headRefName": "claim-characteristics",
      "headRefOid": "be9adcfd6389a409503729ea7d2c9e3e9a7a470b",
      "mergeCommit": null
    },
    {
      "number": 8,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcxMTMxMzg5",
      "title": "Update main file to draft-rats-eat-mandyam-00",
      "url": "https://github.com/ietf-rats-wg/eat/pull/8",
      "state": "MERGED",
      "author": "gmandyam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-04-17T02:00:14Z",
      "updatedAt": "2019-04-17T02:00:56Z",
      "closedAt": "2019-04-17T02:00:56Z",
      "mergedAt": "2019-04-17T02:00:56Z",
      "mergedBy": "gmandyam",
      "comments": [],
      "reviews": [],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "d43880a9817a8f48ca1ec6fda3ce230396feb277",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "2b2d656df73dbbca4baf9766f328a76f3ac5ecd5",
      "mergeCommit": {
        "oid": "2c44d5cad7bfdc98a4e558115324bd03a1abfdee"
      }
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkwNjk4NTM4",
      "title": "Be cwt",
      "url": "https://github.com/ietf-rats-wg/eat/pull/11",
      "state": "MERGED",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Big rearrangement:\r\n- separate information and data model using CDDL\r\n- say an EAT is a CWT or JWT\r\n\r\nNo new claims or any substantive change to any claim.\r\n\r\nI believe I have largely succeeded in using CDDL for the information model and\r\ndefining later how it translates to the CWT and JWT data models.  It seems like\r\nthis is what CDDL is for, but others don't seem to be using it this way (yet). Being \r\nnew to CDDL and attempting what others seem to have not, I may have made some errors since I have no example to follow.\r\n\r\n",
      "createdAt": "2019-06-21T18:02:04Z",
      "updatedAt": "2019-07-03T18:41:30Z",
      "closedAt": "2019-07-03T18:41:30Z",
      "mergedAt": "2019-07-03T18:41:30Z",
      "mergedBy": "laurencelundblade",
      "comments": [],
      "reviews": [],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "2c44d5cad7bfdc98a4e558115324bd03a1abfdee",
      "headRepository": "ietf-rats-wg/eat",
      "headRefName": "be_cwt",
      "headRefOid": "b3cab5e4454229b95fafbc50c3cf7921b7dbc221",
      "mergeCommit": {
        "oid": "b3cab5e4454229b95fafbc50c3cf7921b7dbc221"
      }
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA2NjcxMDE4",
      "title": "Security Considerations",
      "url": "https://github.com/ietf-rats-wg/eat/pull/28",
      "state": "MERGED",
      "author": "gmandyam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "First cut",
      "createdAt": "2019-08-12T21:41:55Z",
      "updatedAt": "2020-02-19T16:57:35Z",
      "closedAt": "2020-02-19T16:57:28Z",
      "mergedAt": "2020-02-19T16:57:28Z",
      "mergedBy": "gmandyam",
      "comments": [
        {
          "author": "gmandyam",
          "authorAssociation": "COLLABORATOR",
          "body": "This has been pending with no comments or feedback. My suggestion is to merge it and then revise as necessary.",
          "createdAt": "2019-10-04T17:03:13Z",
          "updatedAt": "2019-10-04T17:03:13Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this needs clarification of what is meant by \"enclave\".  I think you mean \"manufacturer's cryptographic operation facility\" or such.  ",
          "createdAt": "2019-10-07T04:25:27Z",
          "updatedAt": "2019-10-07T04:25:27Z"
        },
        {
          "author": "gmandyam",
          "authorAssociation": "COLLABORATOR",
          "body": "> \r\n> \r\n> I think this needs clarification of what is meant by \"enclave\". I think you mean \"manufacturer's cryptographic operation facility\" or such.\r\n\r\nModified accordingly with pointer to RFC 4949, where enclave is defined.",
          "createdAt": "2019-10-16T15:53:46Z",
          "updatedAt": "2019-10-16T15:53:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEzMzI3Nzg4",
          "commit": {
            "abbreviatedOid": "f47a8b4"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-07T13:14:21Z",
          "updatedAt": "2019-11-07T13:14:22Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nthe keys used for signing and/or encryption.  In some instances, the manufacturer of the entity\r\n```",
              "createdAt": "2019-11-07T13:14:21Z",
              "updatedAt": "2020-02-19T16:57:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEzMzI5MzYy",
          "commit": {
            "abbreviatedOid": "f47a8b4"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-07T13:17:11Z",
          "updatedAt": "2019-11-07T13:17:12Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nmaterial directly from the secure enclave where it was created to a destination secure enclave where it can be provisioned.\r\n```",
              "createdAt": "2019-11-07T13:17:11Z",
              "updatedAt": "2020-02-19T16:57:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEzMzM0NDAx",
          "commit": {
            "abbreviatedOid": "f47a8b4"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-07T13:25:55Z",
          "updatedAt": "2019-11-07T13:25:56Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "```suggestion\r\nAs stated in Section 8 of {{RFC8392}}, \"The security of the CWT relies upon on the protections offered by COSE\".  Similar considerations apply to EAT when sent as a CWT.  However, the EAT introduces the concept of a nonce\r\n```\r\n\r\nThis would be otherwise incongruent with #42 ",
              "createdAt": "2019-11-07T13:25:55Z",
              "updatedAt": "2020-02-19T16:57:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEzMzY3MDQy",
          "commit": {
            "abbreviatedOid": "f47a8b4"
          },
          "author": "SimonFrost-Arm",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-07T14:14:55Z",
          "updatedAt": "2019-11-07T14:14:56Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "the wording here is unclear, whether the Recommendation applies to use of a Nonce or use of a nonce and encryption + signing? Encryption may not be applicable for all use cases.",
              "createdAt": "2019-11-07T14:14:55Z",
              "updatedAt": "2020-02-19T16:57:16Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "a648f41f4040e94847d2f6669bb0045e4331d53a",
      "headRepository": null,
      "headRefName": "br1",
      "headRefOid": "b899254440826cea379eb1a5115ad08d1ed69898",
      "mergeCommit": {
        "oid": "cf76bd58c185a98a8a9d1637b9030e17f1054a92"
      }
    },
    {
      "number": 29,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE1NjQ2NTg2",
      "title": "Fix capitalization typo",
      "url": "https://github.com/ietf-rats-wg/eat/pull/29",
      "state": "MERGED",
      "author": "ciphergoth",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-09-09T17:54:21Z",
      "updatedAt": "2019-10-01T13:15:34Z",
      "closedAt": "2019-10-01T13:15:34Z",
      "mergedAt": "2019-10-01T13:15:34Z",
      "mergedBy": "laurencelundblade",
      "comments": [],
      "reviews": [],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "cdaecbcdae3a61dcc39aa9601ac72ad8a6203965",
      "headRepository": "ciphergoth/eat",
      "headRefName": "patch-1",
      "headRefOid": "ac2550f0b67320e260df88287dac651ac94549d7",
      "mergeCommit": {
        "oid": "faab2c4351ce31e3d3f7b6b94a0f06c9e5d1cfb9"
      }
    },
    {
      "number": 35,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI1MTIwMzQ3",
      "title": "Up UEID to 256 bits and add design rational appendix",
      "url": "https://github.com/ietf-rats-wg/eat/pull/35",
      "state": "MERGED",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Comments on the analysis are very much requested. \r\n\r\nSee issue #12 and #21",
      "createdAt": "2019-10-07T04:12:27Z",
      "updatedAt": "2020-02-07T15:42:31Z",
      "closedAt": "2020-02-07T15:42:31Z",
      "mergedAt": "2020-02-07T15:42:31Z",
      "mergedBy": "laurencelundblade",
      "comments": [
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "256-bits is plenty. 128-bits as a minimum. This would allow the use of a digested value. If the namespace isn't digested, then you are relying on the namespace authority to manage the population in some way. If the UEID obfuscates the namespace authority then you have to assume there isn't a namespace authority, which implies using digesting. Hence 128-bit is currently practice for minimum acceptable hash lengths. ",
          "createdAt": "2019-10-07T17:27:01Z",
          "updatedAt": "2019-10-07T17:27:01Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "This is ridiculously large.  IPv6 uses an identifier space that is half the number of bits",
          "createdAt": "2019-10-21T12:18:33Z",
          "updatedAt": "2019-10-21T12:18:33Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think 128 bits being enough for IP addresses implies it is enough for UEIDs. IP addresses get reused serially over time and by NAT. Neither reuse applies to UEIDs. Also, a device with a single IP address may have many sub parts that each have a UEID.  They are connected to each other via a bus, a serial link, BlueTooth or such, not IP.\r\n\r\nOn the other hand, I don't think the non-correlation with IP address automatically makes UEIDs 256 bits. 256 bits is based on the probabilistic analysis in the appendix.",
          "createdAt": "2019-11-08T21:34:18Z",
          "updatedAt": "2019-11-08T21:34:18Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "@nedmsmith This discussion is for RAND type UEIDs as you deduced in your comment above. Appendix B should explicitly say that.\r\n\r\nFor crypto, 128 bits is usually considered enough today, but there is always an assumption built into designs that it won't be. Also, there is a lot of use of\r\n256 bits today. For example COSE ECDSA signature are minimum SHA-256.\r\n\r\nIt does seem like UEIDs could start out at 128 bits and transition to 256 bits in ten, twenty or fifty years. All we have to do here and now is say receivers must be prepared for 256 bits. When the time comes a new RFC is issued say 256 bits must be used. The 128-bit and 256-bit UEIDs will coexist just fine. \r\n\r\nI firmly believe we must say now the receivers must be prepared for 256 bits.\r\n\r\nThe question is probably between these two:\r\n\r\n1. Require 256 bits now; waste space for a few decades; no transition will ever be needed.\r\n2. Require only 128 bits now; don't waste space; have a transition if and when the need arises\r\n\r\n\r\n\r\n",
          "createdAt": "2019-11-08T21:48:00Z",
          "updatedAt": "2019-11-08T21:48:00Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "Waste space for a few decades?  The IETF is barely 30 years old.\r\n\r\nAlso, \"128 bits is enough\" -- don't confuse the DIGEST with the crypto KEYLENGTH.  Few people think 128-bit digest is good enough, but most think 128bit AES, for example, is good enough.\r\n",
          "createdAt": "2019-11-08T22:01:13Z",
          "updatedAt": "2019-11-08T22:01:13Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "@richsalz \r\n\r\nAre you in favor of 1 or 2? I assume 1, but don't understand your comment about IETF being 30 years old.\r\n\r\nAgree that my discussion of bits used by crypto today is not very useful here. The only really useful point is that we build in agility to protocols today so they can use more bits when needed.\r\n",
          "createdAt": "2019-11-12T19:58:27Z",
          "updatedAt": "2019-11-12T19:58:27Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "The IETF is 30 years old, planning for \"waste space for a few decades\" when the whole thing has only been around for three seems, well, optimistic? Naive? Wrong? Silly? Because of this, I think 1 is the wrong trade-off and I support 2. (Recall the Internet has already changed core protocols multiple times)",
          "createdAt": "2019-11-12T20:15:24Z",
          "updatedAt": "2019-11-12T20:15:24Z"
        },
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "For me the UEID discussion is strange because UEIDs seem to overload identity and integrity. An IMEI number encodes some information attributes that provides uniqueness within telco networks. There is not expectation of integrity that is provided by some other structure. \r\nIn a perfect world, the structure would be defined using a DDL like CDDL and everything consuming it would support variable length structures. However, the reality is systems are built with fixed length assumptions and so we see schemes that encode multiple attributes into a fixed length structure. If there are many attributes needed to make something \"unique\" then some favor using a hash algorithm since it can reduce anything into a fixed size statistically unique value. The decision to go with 128 or 256 bits has more to do with the intended scope of identifier use. Since UEID intends to combine lots of different identifiers (each being unique within their respective scope) the union of all them creates a larger scope context for understanding uniqueness (aka resistance to collision). Since, nobody (AFAIK) has done an analysis to determine the actual size of the union-of-all-EIDs (UEID), we don't know if 128-bits still has the collision resistance properties it needs. 256 seems safe at least for now. \r\n\r\nAlternatively, EAT / RATS could allow claims that more directly define the identifier type and context. For example, there could be an IMEI claim. \r\n\r\nI'm not sure the intended value of UEID actually exists. \r\n\r\n",
          "createdAt": "2020-01-06T22:42:19Z",
          "updatedAt": "2020-01-06T22:42:19Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "UEIDs can be IMEIs (read the document). UEIDs are only about identity, never about integrity.",
          "createdAt": "2020-01-08T03:02:05Z",
          "updatedAt": "2020-01-08T03:02:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0NTMyNTk3",
          "commit": {
            "abbreviatedOid": "7aa0912"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-21T12:45:32Z",
          "updatedAt": "2019-10-21T12:45:53Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "typo\r\n```suggestion\r\nto internal buses, via serial links, Bluetooth and so on.  This is\r\n```",
              "createdAt": "2019-10-21T12:45:33Z",
              "updatedAt": "2020-02-07T15:31:25Z"
            },
            {
              "originalPosition": 102,
              "body": "```suggestion\r\nHowever, for the very large values involved here, this formula requires floating\r\n```",
              "createdAt": "2019-10-21T12:45:38Z",
              "updatedAt": "2020-02-07T15:31:25Z"
            },
            {
              "originalPosition": 103,
              "body": "```suggestion\r\npoint precision higher than commonly available in calculators and SW so this\r\n```",
              "createdAt": "2019-10-21T12:45:41Z",
              "updatedAt": "2020-02-07T15:31:25Z"
            },
            {
              "originalPosition": 151,
              "body": "```suggestion\r\n32-bytes, is selected because it is the output of the common SHA-256 hash\r\n```",
              "createdAt": "2019-10-21T12:45:45Z",
              "updatedAt": "2020-02-07T15:31:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEzMzI3MTYx",
          "commit": {
            "abbreviatedOid": "7aa0912"
          },
          "author": "setrofim",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-07T13:13:11Z",
          "updatedAt": "2019-11-07T13:13:12Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Typo\r\n```suggestion\r\n## Collision Probability\r\n```",
              "createdAt": "2019-11-07T13:13:12Z",
              "updatedAt": "2020-02-07T15:31:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1Nzk5ODc0",
          "commit": {
            "abbreviatedOid": "fda4a07"
          },
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-12T19:50:55Z",
          "updatedAt": "2019-11-12T19:50:56Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "Grammar",
              "createdAt": "2019-11-12T19:50:55Z",
              "updatedAt": "2020-02-07T15:31:25Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "e0132c0a3bf8abf876b8cfd88c1d92ca4d844ea1",
      "headRepository": "ietf-rats-wg/eat",
      "headRefName": "256bitUEID",
      "headRefOid": "f4ecbb9d381fb536e6dc8b2a0ae2ba088cda0b32",
      "mergeCommit": {
        "oid": "7d9a8de9cf276d7a71b4eaa8bf254f3757966fcf"
      }
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI3MzE3NTAy",
      "title": "Revamp debug disable so it is levels, not Booleans",
      "url": "https://github.com/ietf-rats-wg/eat/pull/36",
      "state": "MERGED",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses #22",
      "createdAt": "2019-10-11T18:30:31Z",
      "updatedAt": "2020-03-19T18:05:38Z",
      "closedAt": "2020-03-19T18:05:30Z",
      "mergedAt": "2020-03-19T18:05:30Z",
      "mergedBy": "laurencelundblade",
      "comments": [
        {
          "author": "SimonFrost-Arm",
          "authorAssociation": "NONE",
          "body": "The change to a set of levels is a good one as it solves inconsistencies with the previous multi claim set.\r\n\r\nPSA calls out a further concept to be tracked for debug: how intrusive the level of debug is, ie. whether it just applies to the non-secure application state or to a higher level of security. The implication of the latter is that the configuration of the device/entity could be compromised making it unsuitable for further trust.",
          "createdAt": "2019-11-07T14:29:40Z",
          "updatedAt": "2019-11-07T14:29:40Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "@SimonFrost-Arm \r\n\r\nI am scared to try to express debug intrusiveness in claims because I'm not sure it can be easily done in a general way. Different CPU and system architectures might be too different. Are you suggesting we try? \r\n\r\nTo go into more detail... Some HW I know of has a whole facility for HW diagnostic and verification. It just helps the HW manufacturer know that the chip actually works. It might be used during RMA to figure what is wrong.\r\n\r\nAnother is a facility like ARM CoreSight. I believe that is connected to through JTAG.\r\n\r\nWhen you talk about PSA secure vs non-secure are you talking about HW or SW debug facilities?\r\n\r\n\r\n\r\n",
          "createdAt": "2019-11-12T19:29:36Z",
          "updatedAt": "2019-11-12T19:29:36Z"
        },
        {
          "author": "henkbirkholz",
          "authorAssociation": "COLLABORATOR",
          "body": "I do not understand how this is supposed to work, tbh. Is this supposed to be a choice of integers that represent a range? If so, it is not doing that. If not, I do not understand what is attempted.\r\n\r\n>     debug_disable_level = (\r\n>         not_disabled: 0, \r\n>         disabled: 1,\r\n>         disabled_since_boot: 2,\r\n>         permanent_disable: 3,\r\n>         full_permanent_disable: 4\r\n>     )\r\n\r\nBranch cddl-fixes includes a \"fixed\" version that still uses bool. If I understand the intent here, I can incorporate that in the cddl-fixes branch.",
          "createdAt": "2019-11-27T20:53:44Z",
          "updatedAt": "2019-11-27T20:53:44Z"
        },
        {
          "author": "SimonFrost-Arm",
          "authorAssociation": "NONE",
          "body": "The intent of the change is to remove the possibility of inconsistency that could occur with the multi bool approach e.g. it would be possible to have a token containing both debug_disabled_since_boot and debug_permanently disabled - which is the case? Replacing the multiple values with a single multi-level value makes the declaration much clearer.",
          "createdAt": "2019-11-28T10:57:06Z",
          "updatedAt": "2019-11-28T10:57:06Z"
        },
        {
          "author": "henkbirkholz",
          "authorAssociation": "COLLABORATOR",
          "body": "If all possible options are mutual exclusive it would look like this:\r\n\r\n> debug_disable_level /= not_disabled\r\n> debug_disable_level /= disabled\r\n> debug_disable_level /= disabled_since_boot\r\n> debug_disable_level /= permanent_disable\r\n> debug_disable_level /= full_permanent_disable\r\n> \r\n> ;this is the CBOR specific value list\r\n> not_disabled = 0\r\n> disabled = 1\r\n> disabled_since_boot =2\r\n> permanent_disable = 3\r\n> full_permanent_disable = 4\r\n",
          "createdAt": "2019-11-28T11:41:57Z",
          "updatedAt": "2019-11-28T11:41:57Z"
        },
        {
          "author": "henkbirkholz",
          "authorAssociation": "COLLABORATOR",
          "body": "After I understood the intent via PR #43 and if you really want to use the \"&\" prefix, the corresponding CDDL for this PR should probably look like this:\r\n\r\n> boot_state_claim = ( boot_state => boot_state_type )\r\n> \r\n> debug_disable_level = (\r\n>   not_disabled,\r\n>   disabled,\r\n>   disabled_since_boot,\r\n>   permanent_disable,\r\n>   full_permanent_disable,\r\n> )\r\n> \r\n> boot_state_type = [\r\n>   secure_boot_enabled: bool,\r\n>   debug_state: &debug_disable_level,\r\n> ]\r\n> \r\n> ;this is the CBOR specific value list\r\n> not_disabled = 0\r\n> disabled = 1\r\n> disabled_since_boot = 2\r\n> permanent_disable = 3\r\n> full_permanent_disable = 4\r\n\r\n",
          "createdAt": "2019-11-28T12:15:36Z",
          "updatedAt": "2019-11-28T12:15:36Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "@henkbirkholz \r\n\r\n> debug_disable_level = (\r\n>     not_disabled: 0, \r\n>     disabled: 1,\r\n>     disabled_since_boot: 2,\r\n>     permanent_disable: 3,\r\n>     full_permanent_disable: 4\r\n> )\r\n\r\nThis seems OK to me because it is the same as section 2.2.2.2 in RFC 8610.\r\n\r\nSeems simpler to do this than the other ways you've proposed. I assume it would work OK for JSON.\r\n\r\nI've fixed the other CDDL that was clearly wrong with a commit.\r\n\r\nThanks for the input.\r\n",
          "createdAt": "2019-12-06T22:29:23Z",
          "updatedAt": "2019-12-06T22:29:23Z"
        },
        {
          "author": "adrianlshaw",
          "authorAssociation": "NONE",
          "body": "> When you talk about PSA secure vs non-secure are you talking about HW or SW debug facilities?\r\n\r\n@laurencelundblade in the PSA definition it can be either or a combination, depending on the hardware platform capabilities. Nothing platform specific is assumed. In fact, \"Secure and non-secure\" isn't actually the term used. The actual states are more about the debug property relative to the root of trust. See the diagram below, but replace \"PRoT\" with your favourite root of trust e.g. TEE. \r\n\r\n![image](https://user-images.githubusercontent.com/762640/71889110-5a884b80-3139-11ea-9b0b-df893498b1dc.png)\r\n\r\nThe Decommissioned state is RMA. The \"Terminate\" process is the point of no return because the root of trust is compromised. \r\n\r\n\"Recoverable PRoT debug\" is an optional state that covers a case where you have special hardware that hides the root secrets while in that mode, making it possible to re-establish trust (go back to \"Secured\") once leaving that mode.",
          "createdAt": "2020-01-07T10:42:56Z",
          "updatedAt": "2020-01-07T10:42:56Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "@SimonFrost-Arm Good comment. Updated with a new Not Reported debug level that is also the default.",
          "createdAt": "2020-01-15T21:53:43Z",
          "updatedAt": "2020-01-15T21:53:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEzMzgwODYz",
          "commit": {
            "abbreviatedOid": "2755c26"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-07T14:34:04Z",
          "updatedAt": "2019-11-07T14:34:05Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "```suggestion\r\nmay be possible to enable them in the future, and it may also be possible that they were enabled in the past after the device booted, but they are currently disabled.\r\n```",
              "createdAt": "2019-11-07T14:34:04Z",
              "updatedAt": "2020-03-19T18:02:16Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "22462da89d970fbb3b5922402263381ea5052692",
      "headRepository": "ietf-rats-wg/eat",
      "headRefName": "update_debug_claim",
      "headRefOid": "cc226daac1d6dcef8bcd71e7bbd1ca4e268fc038",
      "mergeCommit": {
        "oid": "0bc0f9149f544855ba400989efdd9b4961257ef8"
      }
    },
    {
      "number": 41,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI5NDEzMzYx",
      "title": "OEMID clarifications and references",
      "url": "https://github.com/ietf-rats-wg/eat/pull/41",
      "state": "MERGED",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Corrected text and references to match up to the IEEE documents and specs.\r\n\r\nDefines new encoding type, hex_bstr, that encodes to bstr in CBOR for compactness and hexadecimal text in JSON for readability.\r\n\r\nThis is to address #38",
      "createdAt": "2019-10-17T18:59:42Z",
      "updatedAt": "2019-12-05T23:05:26Z",
      "closedAt": "2019-12-05T23:05:18Z",
      "mergedAt": "2019-12-05T23:05:18Z",
      "mergedBy": "laurencelundblade",
      "comments": [
        {
          "author": "henkbirkholz",
          "authorAssociation": "COLLABORATOR",
          "body": "https://standards.ieee.org/products-services/regauth/oui/index.html\r\n\r\nThe IEEE highlights that the term Organizationally Unique Identifier (OUI) is deprecated and superseded by the terms MA-L, MA-M, and MA-S, which are now used for both for EUI-48 and EUI-60.",
          "createdAt": "2019-11-27T20:50:07Z",
          "updatedAt": "2019-11-27T20:50:07Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "@henkbirkholz Yes, this pull request changes to the correct MA-L... terminology.",
          "createdAt": "2019-12-05T22:50:16Z",
          "updatedAt": "2019-12-05T22:50:16Z"
        }
      ],
      "reviews": [],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "bdb24b4b85f06781b66f92d6c458e489d39cd8ab",
      "headRepository": "ietf-rats-wg/eat",
      "headRefName": "update_oui",
      "headRefOid": "2ab6190aa9be537fcb70523c352154d49a75b00b",
      "mergeCommit": {
        "oid": "a69331d7248345bde8fad2de93e4ce39c753be85"
      }
    },
    {
      "number": 42,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMxNzM1NDIx",
      "title": "Add nonce claim, update jti/cti text",
      "url": "https://github.com/ietf-rats-wg/eat/pull/42",
      "state": "MERGED",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #37",
      "createdAt": "2019-10-23T20:40:45Z",
      "updatedAt": "2020-01-06T19:11:21Z",
      "closedAt": "2020-01-06T19:11:21Z",
      "mergedAt": "2020-01-06T19:11:21Z",
      "mergedBy": "laurencelundblade",
      "comments": [
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "@gmandyam in #28 discusses multiple relying parties (RPs) and nonces. There are three ways to solve this. \r\n\r\n1. Each RP can generate their own nonce and send it to the attester. The attester puts them all in. In that case the nonce should be either a bstr with a single nonce or an array of bstr to carry multiple nonces. This is incompatible with the JWT nonce and we'd have to create a new claim it. Call it the multi-nonce claim.\r\n\r\n2. The RP's are expected to coordinate around one nonce and the nonce claim is just a single as it is. This is not too difficult. One of them has to generate it and tell the others what it is. This is compatible with the JWT nonce and with the current text.\r\n\r\n3. We can define two claim types. One is the nonce as is in JWT and as in this PR. The other is the multi-nonce.\r\n\r\nI'm in favor of 2 now. If we really need multiple nonces sometime in the future we can turn it into 3. I guessing multiple nonces will not be that necessary. I can't say that I've seen it any other protocol.",
          "createdAt": "2019-12-06T21:48:50Z",
          "updatedAt": "2019-12-06T21:48:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEzMzM2OTA3",
          "commit": {
            "abbreviatedOid": "faaa9d0"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-07T13:29:58Z",
          "updatedAt": "2019-11-07T13:29:59Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "It is not clear what this means to me.  Besides, in the light of the text proposed in #28\r\n```\r\n[...] Since an EAT may be created by an entity that may not support the same type of transport security as the consumer of the EAT, intermediaries may be required to bridge communications between the entity and consumer.  As a result, it is RECOMMENDED that both the consumer create a nonce, and the entity leverage the nonce along with COSE mechanisms for encryption and signing to create the EAT\r\n```\r\nthis should probably be dropped?",
              "createdAt": "2019-11-07T13:29:59Z",
              "updatedAt": "2019-12-06T22:43:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4NzEwNDc0",
          "commit": {
            "abbreviatedOid": "faaa9d0"
          },
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-19T00:04:30Z",
          "updatedAt": "2019-11-19T00:04:30Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Hi Thomas,\r\n\r\nHave read this over a few times, but I don't know what is not clear to you and what you think should be dropped.\r\n",
              "createdAt": "2019-11-19T00:04:30Z",
              "updatedAt": "2019-12-06T22:43:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4ODYxNjMz",
          "commit": {
            "abbreviatedOid": "faaa9d0"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-19T08:43:45Z",
          "updatedAt": "2019-11-19T08:43:46Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "(Apologies for the late response -- for some reasons I didn't get the nudge from\r\nGitHub on your reply).   The thing that I don't understand is `Note that\r\nintrinsically by the nature of a nonce no security is needed`.  In fact, I think\r\nit's quite the opposite: the nonce is core to the security of the attestation?\r\nMy suggestion is to simply drop the `Note [...] no security is needed`.",
              "createdAt": "2019-11-19T08:43:45Z",
              "updatedAt": "2019-12-06T22:43:18Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "a69331d7248345bde8fad2de93e4ce39c753be85",
      "headRepository": "ietf-rats-wg/eat",
      "headRefName": "nonce",
      "headRefOid": "a02377d0dff75d01c2330039a5aa01fef655c6e5",
      "mergeCommit": {
        "oid": "efd3e2c1217936ca454d8b666e90e1a832a46152"
      }
    },
    {
      "number": 43,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1MjYyMTM0",
      "title": "revamp of submods and nested tokens",
      "url": "https://github.com/ietf-rats-wg/eat/pull/43",
      "state": "MERGED",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This makes nested tokens be part of the submods part of the token with a more unified results.\r\n\r\nIt gets rid of the submod name claim and uses the map label instead.\r\n\r\nIt adds the attachment claim which describes how securely submod is attached.",
      "createdAt": "2019-11-01T03:14:44Z",
      "updatedAt": "2020-02-13T11:15:54Z",
      "closedAt": "2020-02-13T11:15:54Z",
      "mergedAt": "2020-02-13T11:15:54Z",
      "mergedBy": "laurencelundblade",
      "comments": [
        {
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm sorry but what we want to achieve with this change is not clear to me. (I've looked for a related Issue to no avail.) Could you please describe the rationale of this change in an Issue (or point me at an existing one, if I overlooked it)?\r\nAs a meta-comment I think in general it's good practice to open an Issue first where the problem is explained (maybe just pointing to the corresponding mailing list thread, if one exist) and a solution is proposed.  This gives others the opportunity to discuss both the problem and the solution design before it's actually implemented.",
          "createdAt": "2019-11-07T17:28:28Z",
          "updatedAt": "2019-11-07T17:28:28Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "@thomas-fossati \r\n\r\nBefore this change\r\n- Only one nested EAT was possible (without duplicate map keys/labels; duplicating keys/labels is not good form).\r\n- There was no way to name a nested EAT\r\n- A nested EAT was treated separately from a submod so it made writing about inheritance and attachment in common harder.",
          "createdAt": "2019-11-08T21:53:43Z",
          "updatedAt": "2019-11-08T21:53:43Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Here's a comment from Ned that I'm copying to the mainline for easier reference:\r\n\r\n> The submodule could have attestation capability itself in which case the verifier might be instructed to assess the subcomponent claims as another instance of an attestation token. Maybe it makes sense to include an attachment_type for attestable_submod? Additionally, the submodule could be attached using a secure session / protocol. I don't see this represented. The structure is an enumeration, but it is possible for multiple attachment_type conditions to be true at the same time. For example, a submodule could separately attests and be connected via secure session. Possibly attestable_submod is a property that belongs somewhere else? A secure_protocol attachment type could be true as well when one of the other attachment_types are true. Maybe it belongs somewhere else too? (Or these should be booleans).\r\n\r\nNed, it seems like you want to distinguish between \"claims from a submod\" and \"attested claims from a submod\". I don't know what the difference is (yet). Can you give some examples?\r\n\r\nOn attachment_type, we could make it an array of enumerated so you can specify more than one. We could even have an IANA registry for new types.  My thought is to try to come up with a small fixed useful set of classes. If we let 1000 flowers bloom here it will become useless to the relying party. They should be classes, rough categories, not exact types. The vendor has to pick the one most suited.\r\n\r\n\r\n",
          "createdAt": "2019-11-21T00:19:01Z",
          "updatedAt": "2019-11-21T00:19:01Z"
        },
        {
          "author": "SimonFrost-Arm",
          "authorAssociation": "NONE",
          "body": "It would seem that 'attested claims from a submod' is already covered by nested-eat?",
          "createdAt": "2019-11-21T12:08:30Z",
          "updatedAt": "2019-11-21T12:08:30Z"
        },
        {
          "author": "henkbirkholz",
          "authorAssociation": "COLLABORATOR",
          "body": "Same problem as with PR #36 \r\n\r\nIf the CDDL fragment is supposed to be a type choice that represent a range of values, it is not doing that.\r\n\r\n>     attachment_type = (\r\n>     unspecified: 1,\r\n>     device_internal: 2,\r\n>     pcb_internal: 3,\r\n>     chip_internal: 4\r\n>     )\r\n> \r\n>     attachment_type_claim = (\r\n>     attachment: attachment_type )\r\n\r\nIf i understand the intent, I can add corresponding CDDL to the cddl-fixes branch.",
          "createdAt": "2019-11-27T21:03:16Z",
          "updatedAt": "2019-11-27T21:03:16Z"
        },
        {
          "author": "SimonFrost-Arm",
          "authorAssociation": "NONE",
          "body": "I believe the appropriate CDDL would be\r\nattachment_type_claim = &attachment_type\r\nwith attachment_type left as it is as a group. Per 2.2.2.2 of draft-ietf-cbor-cddl-03.\r\n\r\nThis encoding already appears to be in place in PR36",
          "createdAt": "2019-11-28T11:10:28Z",
          "updatedAt": "2019-11-28T11:10:28Z"
        },
        {
          "author": "henkbirkholz",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. https://tools.ietf.org/html/rfc8610#section-2.2.2.2 is an alternative use. Typically, it is used for either for a large number of values or if the group is also used in other contexts. In general, this is fine, too. It is just me being personally a bit more in favor of the style I just highlighted in #36.\r\n\r\nPR #36 is broken nevertheless (sorry for the cross issue post), as the will not work, it  also uses string labels with implied cuts, and you cannot use a rule inside as an array item. I'll post another comment there.\r\n\r\nComing back to this PR. I assume what you want looks more like this (I'd also start with index \"0\" to be consistent with PR #36:\r\n\r\n> attachment_type_claim = ( attachment => &attachment_type )\r\n> \r\n> attachment_type = (\r\n>   unspecified,\r\n>   device_internal,\r\n>   pcb_internal,\r\n>   chip_internal,\r\n> )\r\n> \r\n> ;this is the CBOR specific value list\r\n> unspecified = 0\r\n> device_internal = 1\r\n> pcb_internal = 2\r\n> chip_internal = 3\r\n\r\n\r\n",
          "createdAt": "2019-11-28T12:04:04Z",
          "updatedAt": "2019-11-28T12:04:04Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "> It would seem that 'attested claims from a submod' is already covered by nested-eat?\r\n\r\nThis PR replaces the nested-eat claim. ",
          "createdAt": "2019-12-06T22:02:52Z",
          "updatedAt": "2019-12-06T22:02:52Z"
        },
        {
          "author": "nedmsmith",
          "authorAssociation": "NONE",
          "body": "Laurence said \"Ned, it seems like you want to distinguish between \"claims from a submod\" and \"attested claims from a submod\". I don't know what the difference is (yet). Can you give some examples?\"\r\nAttested means signed by an Attester. If the submods/nested-eat allows for 'unsigned EAT' structures then it is possible to describe components that exist but are not 'attested'. There is a security semantic that could become misinterpreted by Verifiers if signing of something that is nested wasn't inspected by the Attester. Example is a peripheral device that is enumerated by BIOS but contains embedded firmware (as opposed to option-ROM). The BIOS is in the Attester but can't inspect the embedded firmware of the peripheral device. It can assert that the device exists (was enumerated) but can't vouch for the integrity of its firmware. The peripheral should be a second Attester based on a root of trust that exists in the peripheral. \r\n\r\nIf the EAT structure describes both the peripheral device (D1) and the main board / platform (P1) then the Attester for P1 will likely sign an EAT that contains P1 claims (p0, p1, p2,...) and D1 claims (d0, d1, d2, d3,...) using the P1 attestation key. If [] denotes signing, the claim might look like [[p0, p1, p2, [d0, d1, d2,...]KD1 ]KP1; where K denotes a signing key. \r\n\r\nIf on the other hand, there isn't an attester for D1, but P1 wants to assert that D1 exists. Then it would product an EAT with the structure [p0, p1, p2,..., d0, d1, d2, ...]KP1 \r\n\r\nThe point of possible confusion by the Verifier is whether or not P1 is saying that D1 exists or that D1 is attested by P1; where \"attested\" also (in addition to signing) means that the integrity of D1 is proven to be correct because of some special access P1 has to D1. \r\n\r\nThe Interface (attachment_type) claim may be helpful in that it could describe the relationship between P1 and D1. For example, if D1 firmware were stored in memory that is dual ported to P1 then P1 could directly read it and compute its hash. However, the current interface claim structure doesn't describe the security relevant properties of the interface (AFAK).\r\n\r\nI think the architecture intends for Attester to mean an environment that has special access to the Attestee such that it can prove its state is X AND that it can sign claims about X. \r\n\r\nIf the structure of nested EATs somehow allows the Attester/Attestee relationships to breakdown then Verifiers will be confused about the security properties of what an EAT is asserting. ",
          "createdAt": "2020-01-06T22:15:22Z",
          "updatedAt": "2020-01-06T22:15:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEzMzQ2NjU2",
          "commit": {
            "abbreviatedOid": "5606f48"
          },
          "author": "SimonFrost-Arm",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-07T13:45:34Z",
          "updatedAt": "2019-11-07T13:45:35Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "If submods are used structurally within an EAT, they should be able to have the same level of security as the EAT (rather than making lesser security mandatory). May just be unfortunate usage of the word 'should' and can be stated as 'not higher'?",
              "createdAt": "2019-11-07T13:45:34Z",
              "updatedAt": "2020-02-13T11:13:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEzMzU0OTI3",
          "commit": {
            "abbreviatedOid": "5606f48"
          },
          "author": "SimonFrost-Arm",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-07T13:57:37Z",
          "updatedAt": "2019-11-07T13:57:37Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "this seems to contradict line 755 which mandates the inclusion of all such claims.\r\nShould there be an explicit statement (or claim value) for whether submod is expected to inherit or not rather than making it implicit on attachment type?",
              "createdAt": "2019-11-07T13:57:37Z",
              "updatedAt": "2020-02-13T11:13:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEzMzU2ODcx",
          "commit": {
            "abbreviatedOid": "5606f48"
          },
          "author": "SimonFrost-Arm",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-07T14:00:25Z",
          "updatedAt": "2019-11-07T14:00:25Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "mismatch here with naming @ line 660",
              "createdAt": "2019-11-07T14:00:25Z",
              "updatedAt": "2020-02-13T11:13:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1Nzk1ODEw",
          "commit": {
            "abbreviatedOid": "5606f48"
          },
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-12T19:44:09Z",
          "updatedAt": "2019-11-12T19:44:09Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "Oversight. Should be less than or equal too. Thanks for catching.",
              "createdAt": "2019-11-12T19:44:09Z",
              "updatedAt": "2020-02-13T11:13:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1Nzk5MTE0",
          "commit": {
            "abbreviatedOid": "5606f48"
          },
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-12T19:49:36Z",
          "updatedAt": "2019-11-12T19:49:36Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Line 754 is explicit that there is no inheritance.\r\n\r\nAgree that the wording here is fuzzy.\r\n\r\nThe nonce is intrinsically different from other claims as it does not describe the entity. It comes from the relying party to prevent replay. To replicate or not replicate the nonce could be considered to not be an inheritance question and we could have explicit text spelling all this out.",
              "createdAt": "2019-11-12T19:49:36Z",
              "updatedAt": "2020-02-13T11:13:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1Nzk5MzA0",
          "commit": {
            "abbreviatedOid": "5606f48"
          },
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-12T19:49:55Z",
          "updatedAt": "2019-11-12T19:49:55Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Agreed",
              "createdAt": "2019-11-12T19:49:55Z",
              "updatedAt": "2020-02-13T11:13:28Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "7d9a8de9cf276d7a71b4eaa8bf254f3757966fcf",
      "headRepository": "ietf-rats-wg/eat",
      "headRefName": "submods_revamp",
      "headRefOid": "622711b698cedb42e77b9b576cc065542601c784",
      "mergeCommit": {
        "oid": "2c14b48b2b43df2f23f1c6c0a0540f4ee1db8331"
      }
    },
    {
      "number": 47,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ2MzgxMzg3",
      "title": "added first pass of (Co)SWID and SUIT Manifest Claims",
      "url": "https://github.com/ietf-rats-wg/eat/pull/47",
      "state": "OPEN",
      "author": "henkbirkholz",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a first proposal for content matching the proposal in issue https://github.com/ietf-rats-wg/eat/issues/46.",
      "createdAt": "2019-11-27T18:47:22Z",
      "updatedAt": "2019-11-27T22:33:49Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "henkbirkholz",
          "authorAssociation": "COLLABORATOR",
          "body": "There is a lesson learned here.... \ud83d\ude48\r\n\r\nUsing an \"&\" in a branch name does not make CircleCI very happy...\r\n\r\n> mkdir -p /tmp/ghpages127/coswid-&-suit-mainfest-claims\r\n> bash: -suit-mainfest-claims: command not found\r\n> lib/ghpages.mk:56: recipe for target '/tmp/ghpages127/coswid-&-suit-mainfest-claims' failed",
          "createdAt": "2019-11-27T18:51:40Z",
          "updatedAt": "2019-11-27T18:51:40Z"
        }
      ],
      "reviews": [],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "5bfb9df8c6c6043a71bc98c140a100e4a0c278c6",
      "headRepository": "ietf-rats-wg/eat",
      "headRefName": "coswid-&-suit-mainfest-claims",
      "headRefOid": "beff915ec4debd38d6137ed902b69ddf40d0666d",
      "mergeCommit": null
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ2NDE5NjQ3",
      "title": "first pass on fixing CDDL specification fragments ",
      "url": "https://github.com/ietf-rats-wg/eat/pull/48",
      "state": "OPEN",
      "author": "henkbirkholz",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "According to the new intend of using is as a data model for EAT, initial focus on CWT",
      "createdAt": "2019-11-27T20:46:03Z",
      "updatedAt": "2019-12-07T00:44:20Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @henkbirkholz for this. It is helpful and I've been using it to update the other PRs. I probably won't merge this, just use parts in the other PRs because it has lots of merge conflicts with the other PRs. I will leave it open until all the CDDL is resolved.\r\n",
          "createdAt": "2019-12-07T00:44:20Z",
          "updatedAt": "2019-12-07T00:44:20Z"
        }
      ],
      "reviews": [],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "5bfb9df8c6c6043a71bc98c140a100e4a0c278c6",
      "headRepository": "ietf-rats-wg/eat",
      "headRefName": "cddl-fixes",
      "headRefOid": "e144f73d145f42fa63278675353ba1d30292b2c8",
      "mergeCommit": null
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc0ODgwNzY5",
      "title": "Lots of CDDL fixes",
      "url": "https://github.com/ietf-rats-wg/eat/pull/52",
      "state": "MERGED",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-13T13:54:03Z",
      "updatedAt": "2020-02-19T11:35:04Z",
      "closedAt": "2020-02-19T11:35:04Z",
      "mergedAt": "2020-02-19T11:35:04Z",
      "mergedBy": "laurencelundblade",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4Mjg5Nzg5",
          "commit": {
            "abbreviatedOid": "db6096a"
          },
          "author": "henkbirkholz",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-13T15:05:04Z",
          "updatedAt": "2020-02-18T09:04:40Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "s/defineeach/define each/g",
              "createdAt": "2020-02-13T15:05:04Z",
              "updatedAt": "2020-02-19T11:33:45Z"
            },
            {
              "originalPosition": 54,
              "body": "As the CDDL fixes are based on PR #48 posted by me. Is the change back to string label here intentional?\r\n\r\nAlso, why allow for 7 byte length (56 bit)? Also, the max size is now 264 bit. Is there a reason I missed?\r\n\r\nIf we want to allow for 128 bit and 256 bit. I'd still propose\r\n\r\nueid-claim /= ( ueid => bytes .size 16 )\r\nueid-claim /= ( ueid => bytes .size 32 )\r\n\r\nand do not understand this change, to be honest.",
              "createdAt": "2020-02-13T19:47:43Z",
              "updatedAt": "2020-02-19T11:33:45Z"
            },
            {
              "originalPosition": 72,
              "body": "What is string-or-uri?\r\n\r\nA reference to a cddl type definition would be useful. If there is none, I'd still propose\r\n\r\norigination-claim = ( origination => text / URI )\r\n\r\nas in PR #48\r\n\r\nAlso, is it intentional that this is a string label, too?",
              "createdAt": "2020-02-13T19:50:02Z",
              "updatedAt": "2020-02-19T11:33:45Z"
            },
            {
              "originalPosition": 96,
              "body": "Again a string label.\r\n\r\nAlso, should this not be size differentiated by eui-48 and eui-64 wrt MA-L?\r\n\r\nAlso, new first time customers cannot get MA-L anymore. Should we therefore explicitly differentiate MA-M and MA-S, too? This is in the text, but not captured by CDDL controls. ",
              "createdAt": "2020-02-13T19:59:43Z",
              "updatedAt": "2020-02-19T11:33:45Z"
            },
            {
              "originalPosition": 155,
              "body": "String labels",
              "createdAt": "2020-02-18T08:56:19Z",
              "updatedAt": "2020-02-19T11:33:45Z"
            },
            {
              "originalPosition": 202,
              "body": "location => location-type",
              "createdAt": "2020-02-18T08:56:42Z",
              "updatedAt": "2020-02-19T11:33:45Z"
            },
            {
              "originalPosition": 378,
              "body": "latitude = \"lat\"",
              "createdAt": "2020-02-18T09:03:10Z",
              "updatedAt": "2020-02-19T11:33:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMjU1NjI4",
          "commit": {
            "abbreviatedOid": "db6096a"
          },
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-18T11:14:12Z",
          "updatedAt": "2020-02-18T11:14:13Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "This is an OUI or CD, not EUI.\r\n\r\nIt needs to be possible to use OUIs and such that were obtained 20-30 years ago, so it is OK as is.",
              "createdAt": "2020-02-18T11:14:12Z",
              "updatedAt": "2020-02-19T11:33:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMjU1ODI2",
          "commit": {
            "abbreviatedOid": "db6096a"
          },
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-18T11:14:34Z",
          "updatedAt": "2020-02-18T11:14:34Z",
          "comments": [
            {
              "originalPosition": 378,
              "body": "Fixed",
              "createdAt": "2020-02-18T11:14:34Z",
              "updatedAt": "2020-02-19T11:33:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMjU2MzUx",
          "commit": {
            "abbreviatedOid": "db6096a"
          },
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-18T11:15:22Z",
          "updatedAt": "2020-02-18T11:15:22Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "It is defined later in the doc roughly as you suggest.",
              "createdAt": "2020-02-18T11:15:22Z",
              "updatedAt": "2020-02-19T11:33:45Z"
            }
          ]
        }
      ],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "136d631593e21078c3d1010f1866ce837f7ed189",
      "headRepository": "ietf-rats-wg/eat",
      "headRefName": "ll_cddl_fixes",
      "headRefOid": "28f56165762c5b073c43e458631bf608ea05e0d7",
      "mergeCommit": {
        "oid": "a648f41f4040e94847d2f6669bb0045e4331d53a"
      }
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgxMzczNzA2",
      "title": "Fix sentences describing Major type 2 and other types",
      "url": "https://github.com/ietf-rats-wg/eat/pull/56",
      "state": "MERGED",
      "author": "puiterwijk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-28T12:48:51Z",
      "updatedAt": "2020-03-19T18:06:21Z",
      "closedAt": "2020-03-19T18:06:21Z",
      "mergedAt": "2020-03-19T18:06:21Z",
      "mergedBy": "laurencelundblade",
      "comments": [],
      "reviews": [],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "22462da89d970fbb3b5922402263381ea5052692",
      "headRepository": "puiterwijk/eat",
      "headRefName": "fixtypes",
      "headRefOid": "ff3604d2de7f477bb6241f6ff900bdeb55705d28",
      "mergeCommit": {
        "oid": "fd566501ef6d4de679b8feee7415eacc0e209bcb"
      }
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk0OTc0MTkx",
      "title": "clarify iat claim; remove age claim; add timestamp to location",
      "url": "https://github.com/ietf-rats-wg/eat/pull/59",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is to address the timing diagram from Eric Voit and others. \r\n\r\nTimestamping of measurements is very important, but no measurement is defined in EAT (yet).\r\n",
      "createdAt": "2020-03-27T21:19:41Z",
      "updatedAt": "2020-11-06T19:33:30Z",
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "6c97e22dbce3e2e5f4e8d573f42167e3aa3401ad",
      "headRepository": "ietf-rats-wg/eat",
      "headRefName": "timestamp",
      "headRefOid": "9d55bd77ac2930bedeb974dcaf5a4d1e3ce7a9df",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk1MTYxMDc0",
      "title": "Context claim",
      "url": "https://github.com/ietf-rats-wg/eat/pull/60",
      "state": "OPEN",
      "author": "gmandyam",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://github.com/ietf-rats-wg/eat/issues/57",
      "createdAt": "2020-03-28T22:00:06Z",
      "updatedAt": "2020-03-28T22:00:06Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "aac5de214068993208b41066f1717222abde6114",
      "headRepository": "gmandyam/eat",
      "headRefName": "context",
      "headRefOid": "aaec8cd22fb6493903a201117cd64d5909c45ec1",
      "mergeCommit": null
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA2MjY1OTc1",
      "title": "Disallow floating-point dates",
      "url": "https://github.com/ietf-rats-wg/eat/pull/61",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "CWT allows floating-point dates, but they are of no value and add an implementation burden, thus EAT is disallowing them.\r\n",
      "createdAt": "2020-04-20T19:48:40Z",
      "updatedAt": "2020-04-20T19:48:40Z",
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "aac5de214068993208b41066f1717222abde6114",
      "headRepository": "ietf-rats-wg/eat",
      "headRefName": "no-float",
      "headRefOid": "b4e93a6884d70775e676ec7e93de2b2167102b1b",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 62,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA2NzU0Nzky",
      "title": "Add defintion of UCCS and UJCS",
      "url": "https://github.com/ietf-rats-wg/eat/pull/62",
      "state": "CLOSED",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "UCCS and UJCS are unprotected CWT/JWT for use in contexts where protection is unnecessary or provided by other means.",
      "createdAt": "2020-04-21T15:59:35Z",
      "updatedAt": "2020-10-28T18:10:50Z",
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "aac5de214068993208b41066f1717222abde6114",
      "headRepository": "ietf-rats-wg/eat",
      "headRefName": "uccs",
      "headRefOid": "ed0e34b92c3efdfd9d44fc99ab8bf40f15ee79a4",
      "closedAt": "2020-10-28T18:10:50Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "jimsch",
          "authorAssociation": "NONE",
          "body": "The JOSE way to do this is (shudder) to create a JWT with the signature algorithm of None.  You probably need to review this depending on where you are planning to use this.",
          "createdAt": "2020-04-21T16:45:50Z",
          "updatedAt": "2020-04-21T16:45:50Z"
        },
        {
          "author": "gmandyam",
          "authorAssociation": "COLLABORATOR",
          "body": "Is this meant to address https://github.com/ietf-rats-wg/eat/issues/54?  If not, which issue is associated with the PR?",
          "createdAt": "2020-04-21T16:51:52Z",
          "updatedAt": "2020-04-21T16:51:52Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, this is to address #54 ",
          "createdAt": "2020-04-26T08:21:42Z",
          "updatedAt": "2020-04-26T08:21:42Z"
        },
        {
          "author": "laurencelundblade",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed because UCCS is now in a separate draft by Henk",
          "createdAt": "2020-10-28T18:10:50Z",
          "updatedAt": "2020-10-28T18:10:50Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 66,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEwMjA1NTQx",
      "title": "Clarify and simplify way IMEIs are encoded",
      "url": "https://github.com/ietf-rats-wg/eat/pull/66",
      "state": "MERGED",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "IMEI is encoded as byte string of 14 bytes eliminating confusion about big/little endian and conversion to/from an integer value. \r\n\r\nDoes make IMEI's encode to 14 bytes instead of 6 so there's a little bit of wasted space due to this.",
      "createdAt": "2020-10-26T17:53:25Z",
      "updatedAt": "2020-11-03T18:41:36Z",
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "ce8393575f5038919f3128f61efecc56c27d4a80",
      "headRepository": "ietf-rats-wg/eat",
      "headRefName": "IMEI_Encoding",
      "headRefOid": "b52cda59ce5dd00f0629906b05a92ed86239b6a9",
      "closedAt": "2020-11-03T18:41:36Z",
      "mergedAt": "2020-11-03T18:41:36Z",
      "mergedBy": "laurencelundblade",
      "mergeCommit": {
        "oid": "8e3aa5671999d555afc142368445386b20af2f87"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 67,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEwMzA4Nzk5",
      "title": "submods: UCCS, bstr wrapping, tagging rules",
      "url": "https://github.com/ietf-rats-wg/eat/pull/67",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Allows UCCS tokens\r\n\r\nIncorporates JWTs, secured and unsecured.\r\n\r\nRequires nested CWT submodules be bstr wrapped.\r\n\r\nHow to bring a UCCS in as a submodule.\r\n\r\nHow to put a JWT submodule in a CWT and vice versa.\r\n\r\nAll the rules for CWT and COSE tag usage.\r\n\r\nTop-level CDDL to handle CWT/COSE, UCCS and JWT",
      "createdAt": "2020-10-26T21:07:48Z",
      "updatedAt": "2020-11-04T21:06:59Z",
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "6c97e22dbce3e2e5f4e8d573f42167e3aa3401ad",
      "headRepository": "ietf-rats-wg/eat",
      "headRefName": "submod_update",
      "headRefOid": "c9c9b3ad653c99c39b8576c483aaaf1f070bf35f",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 68,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEwOTc0Njk3",
      "title": "Add chip, board and device versions based on EAN-13",
      "url": "https://github.com/ietf-rats-wg/eat/pull/68",
      "state": "OPEN",
      "author": "laurencelundblade",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Address #33 \r\n\r\nean-chip-version is exactly the same as psa-hardware-version from ARM's PSA token definition.\r\nhttps://tools.ietf.org/id/draft-tschofenig-rats-psa-token-05.html\r\n\r\nIt may also be desirable to have non-EAN version claims since not all will use EANs and EANs require obtaining manufacture codes from GS1.",
      "createdAt": "2020-10-27T18:41:09Z",
      "updatedAt": "2020-10-27T18:41:09Z",
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "ce8393575f5038919f3128f61efecc56c27d4a80",
      "headRepository": "ietf-rats-wg/eat",
      "headRefName": "ean_version",
      "headRefOid": "a9236a188a3773b8a35d90b8838eae22d9bd595f",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 69,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE0MTQzNDQ2",
      "title": "Factor out CDDL",
      "url": "https://github.com/ietf-rats-wg/eat/pull/69",
      "state": "MERGED",
      "author": "thomas-fossati",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Reviewing the editor draft, I noticed the CDDL had a few errors and that the examples were drifting away. Therefore I have taken the liberty to do some restructuring to increase internal coherency, remove any need to copy&paste, and more generally automate all things around CDDL and examples.  Specifically:\r\n\r\n* Extract CDDL for each claim into its own snippet file which is sourced from the markdown;\r\n* Build the amalgamated CDDL from all the snippets automatically and source it from the markdown;\r\n* Make the examples validate against the CDDL as a build/deploy precondition.\r\n\r\nIn the process I had to do the following pretty arbitrary moves:\r\n* Fix the nonce claim to allow both array and scalar;\r\n* Commented out `generic-claim-type` which was used without being defined;\r\n* Consequently dropped from the examples the custom claims;\r\n* Give EAT claims a code-point.\r\n\r\nThere is now a dependency on a couple of tools: `cddl` and `diag2cbor`.  I have made the Travis based CI work with them.  Hopefully Travis is the CI in use in the main repo?  If not, we'll need to port the changes to the target CI environment.\r\n\r\nPS: the JSON claims have not been included yet in the full CDDL.",
      "createdAt": "2020-11-02T15:39:25Z",
      "updatedAt": "2020-11-04T09:46:46Z",
      "baseRepository": "ietf-rats-wg/eat",
      "baseRefName": "master",
      "baseRefOid": "ce8393575f5038919f3128f61efecc56c27d4a80",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "4b85a239b69e78f4e97f8b3f91c662fc1de0e43a",
      "closedAt": "2020-11-03T19:39:48Z",
      "mergedAt": "2020-11-03T19:39:48Z",
      "mergedBy": "laurencelundblade",
      "mergeCommit": {
        "oid": "6c97e22dbce3e2e5f4e8d573f42167e3aa3401ad"
      },
      "comments": [
        {
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> There is now a dependency on a couple of tools: `cddl` and `diag2cbor`. I have made the Travis based CI work with them. Hopefully Travis is the CI in use in the main repo? If not, we'll need to port the changes to the target CI environment.\r\n\r\nI have made an image at https://hub.docker.com/repository/docker/thomasfossati/i-d-template that could be used for the circle CI.\r\n\r\nI've also opened a PR on the upstream i-d-template: https://github.com/martinthomson/i-d-template/pull/250",
          "createdAt": "2020-11-04T09:46:45Z",
          "updatedAt": "2020-11-04T09:46:45Z"
        }
      ],
      "reviews": []
    }
  ]
}